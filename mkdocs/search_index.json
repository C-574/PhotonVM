{
    "docs": [
        {
            "location": "/",
            "text": "Home\n\u00b6\n\n\nPhotonVM is a register-based virtual machine that is written in C++ with the goals to be very small, in code size and byte code size, while still being a fully functional interpreted language. It was mostly written for educational purposes (and for fun, of course). \n\n\nThis site contains all documentation about the Photon VM. To \nget started\n see the \nIntegration Guide\n.\n\n\n\n\nBreaking Changes\n\n\nThe current major version (\n2.x\n) introduces breaking changes to existing code. It is recommended to upgrade to the new version if possible.\n\n\n\n\nFeatures\n\u00b6\n\n\nSome of the features of Photon are:\n\n\n\n\nEasy to integrate (\nonly a single file\n) with customizable interface for the host application\n\n\nNo external dependencies (\nexcept\n for the C/C++ standard library and a C++11 compatible compiler)\n\n\nSmall but fully functional instruction set\n\n\nGenerates very small byte-code output (16-bits per instruction)\n\n\nCan compile and run Photon source code or pre-compiled byte-code\n\n\nNo dynamic memory allocation at byte-code runtime \n\n\nMIT licensed\n\n\n\n\nThe name \nPhoton\n was chosen because every instruction that can be executed is very small and lightweight, as they are packed into only 16-bits. \n\n\nThe code that the Photon compiler packs into an executable format is very Assembly-like and linear. Also the VM is portable between different operating systems (currently tested on MSVC 2015).\n\n\nExamples\n\u00b6\n\n\nThis section shows a list of examples on how to use Photon source code to do some simple things.\n\n\nFor a more complete example on how to use Photon on the C++ side, see the example files in the \n/src\n directory. The PVM sample (\npvm.cpp\n) will show how to compile byte-code and execute it using Photon including some utillity functions.\n\n\nHello World\n\u00b6\n\n\nThis simple example is kind of the \n\"Hello World\"\n of Photon. It shows how to add two values together and print the resulting value to the screen.\n\n# Store two values in two registers for addition.\n\n\nset\n \nreg0\n \n3\n\n\nset\n \nreg1\n \n7\n\n\n\n# Let the VM add both registers together and store the result in another register, 'local' in this case.\n\n\nadd\n \nreg3\n \nreg0\n \nreg1\n\n\n\n# Call the host application to output the calculated value to the console.\n\n\nhcl\n \n0\n \n2\n\n\n\n# Halt the execution of the VM.\n\n\nhalt\n \n0\n\n\n\n\nFibonacci\n\u00b6\n\n\nThis example shows how to compute the Fibonacci sequence to a specific number of iterations.\nThis is a pretty complex example as it makes use of the \njmp\n instruction to imitate a while-loop. \n\n\nThe number of iterations of the algorithm is defined by the value of the \nreg0\n register while the result of the Fibonacci sequence computation is stored in the \nreg1\n register. This script ignores printing the result to the host application's output for simplicity.\n\n# Mapping Table:\n\n\n# -----------------\n\n\n# N:        | reg0\n\n\n# Fib       | reg1\n\n\n# FibN-1    | reg2\n\n\n# FibN-2    | reg3\n\n\n# i         | reg4 \n\n\n# blockSize | reg5\n\n\n# local <= reg12\n\n\n# ------------------\n\n\n\n# Defines the iteration count of the algorithm.\n\n\nset\n \nreg0\n \n18\n\n\n\n# Define the variables that are used to compute the sequence.\n\n\nset\n \nreg1\n \n0\n\n\nset\n \nreg2\n \n0\n\n\nset\n \nreg3\n \n1\n\n\n\n\n# reg5 = instruction count of loop-block.\n\n\nset\n \nreg5\n \n9\n\n\n# reg4 = start index of loop (i).\n\n\nset\n \nreg4\n \n2\n\n\n\n# while(i < N) ...\n\n\ngre\n \nreg12\n \nreg4\n \nreg0\n\n\nmul\n \nreg12\n \nreg12\n \nreg5\n\n\njmp\n \nreg12\n \n0\n\n\n# BEGIN - While\n\n    \nadd\n \nreg1\n \nreg2\n \nreg3\n\n    \ncpy\n \nreg2\n \nreg3\n\n    \ncpy\n \nreg3\n \nreg1\n\n\n    \n# Increment the loop counter 'i'.\n\n    \nset\n \nreg12\n \n1\n\n    \nadd\n \nreg4\n \nreg4\n \nreg12\n\n    \n# jump back to the loop-head.\n\n    \nset\n \nreg12\n \n10\n\n    \ninv\n \nreg12\n\n    \njmp\n \nreg12\n \n0\n\n\n# END - While\n\n\n\nhalt\n \n0",
            "title": "Home"
        },
        {
            "location": "/#home",
            "text": "PhotonVM is a register-based virtual machine that is written in C++ with the goals to be very small, in code size and byte code size, while still being a fully functional interpreted language. It was mostly written for educational purposes (and for fun, of course).   This site contains all documentation about the Photon VM. To  get started  see the  Integration Guide .   Breaking Changes  The current major version ( 2.x ) introduces breaking changes to existing code. It is recommended to upgrade to the new version if possible.",
            "title": "Home"
        },
        {
            "location": "/#features",
            "text": "Some of the features of Photon are:   Easy to integrate ( only a single file ) with customizable interface for the host application  No external dependencies ( except  for the C/C++ standard library and a C++11 compatible compiler)  Small but fully functional instruction set  Generates very small byte-code output (16-bits per instruction)  Can compile and run Photon source code or pre-compiled byte-code  No dynamic memory allocation at byte-code runtime   MIT licensed   The name  Photon  was chosen because every instruction that can be executed is very small and lightweight, as they are packed into only 16-bits.   The code that the Photon compiler packs into an executable format is very Assembly-like and linear. Also the VM is portable between different operating systems (currently tested on MSVC 2015).",
            "title": "Features"
        },
        {
            "location": "/#examples",
            "text": "This section shows a list of examples on how to use Photon source code to do some simple things.  For a more complete example on how to use Photon on the C++ side, see the example files in the  /src  directory. The PVM sample ( pvm.cpp ) will show how to compile byte-code and execute it using Photon including some utillity functions.",
            "title": "Examples"
        },
        {
            "location": "/#hello-world",
            "text": "This simple example is kind of the  \"Hello World\"  of Photon. It shows how to add two values together and print the resulting value to the screen. # Store two values in two registers for addition.  set   reg0   3  set   reg1   7  # Let the VM add both registers together and store the result in another register, 'local' in this case.  add   reg3   reg0   reg1  # Call the host application to output the calculated value to the console.  hcl   0   2  # Halt the execution of the VM.  halt   0",
            "title": "Hello World"
        },
        {
            "location": "/#fibonacci",
            "text": "This example shows how to compute the Fibonacci sequence to a specific number of iterations.\nThis is a pretty complex example as it makes use of the  jmp  instruction to imitate a while-loop.   The number of iterations of the algorithm is defined by the value of the  reg0  register while the result of the Fibonacci sequence computation is stored in the  reg1  register. This script ignores printing the result to the host application's output for simplicity. # Mapping Table:  # -----------------  # N:        | reg0  # Fib       | reg1  # FibN-1    | reg2  # FibN-2    | reg3  # i         | reg4   # blockSize | reg5  # local <= reg12  # ------------------  # Defines the iteration count of the algorithm.  set   reg0   18  # Define the variables that are used to compute the sequence.  set   reg1   0  set   reg2   0  set   reg3   1  # reg5 = instruction count of loop-block.  set   reg5   9  # reg4 = start index of loop (i).  set   reg4   2  # while(i < N) ...  gre   reg12   reg4   reg0  mul   reg12   reg12   reg5  jmp   reg12   0  # BEGIN - While \n     add   reg1   reg2   reg3 \n     cpy   reg2   reg3 \n     cpy   reg3   reg1 \n\n     # Increment the loop counter 'i'. \n     set   reg12   1 \n     add   reg4   reg4   reg12 \n     # jump back to the loop-head. \n     set   reg12   10 \n     inv   reg12 \n     jmp   reg12   0  # END - While  halt   0",
            "title": "Fibonacci"
        },
        {
            "location": "/manual/language/",
            "text": "The Language\n\u00b6\n\n\nThe PhotonVM source code language is similar to the Assembly language, as it consists of a series of instructions that are combined to create an executable program. An instruction is defined by the name of the instruction to call and a list of up to three parameters, for example:\n\n    \ninstr\n \nparam1\n \nparam2\n \nparam3\n   \n\n\n\nEvery instruction only operates on the VM registers and has no stack or dynamic memory like other languages. Also an instruction can only take either up to three registers or a single constant as a parameter per instruction, if any are supported for the specific instruction.\n\n\nParameters can be of tow types:\n\n\n\n\nRegister\n: Registers are addressed as \nreg0 - reg12\n or \nr0 - r12\n\n\nConstant value\n: Constants are represented as \n123\n. The valid range for constants is [0, 255]\n\n\n\n\nThe order of execution is linear, so the first instruction in the source or byte-code will be the first one to be executed (FIFO).\n\n\nComments\n\u00b6\n\n\nThe Photon language also supports basic line comments to add notes or documentation to Photon source code. A comment starts with \n#\n and is completely ignored by the Photon compiler when generating executable byte-code. Multiline comments are not supported.\n\n    \n# This is a comment.\n\n    \ninv\n \nreg0\n\n\n    \ninv\n \nreg0\n \n# A comment after an instruction.\n\n\n\n\nInstructions\n\u00b6\n\n\nAs Photon uses only 16-bits to encode an instruction, it has a very limited but powerful set of instructions. The following table shows all instructions that are currently supported:\n\n\n\n\n\n\n\n\nOp Code\n\n\nSyntax\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n0x0\n\n\nhalt \n[exitCode]\n\n\nHalts the execution of the virtual machine immediately. A value of \n0\n represents success. The host can check the result of the execution. See \nVMExitCodes\n enumeration for predefined codes.\n\n\n\n\n\n\n0x1\n\n\nset \n[destRegister] [value]\n\n\nWrites a constant value to a specific VM register. To clear a register set it to \n0\n (zero). Note that by default all registers are reset to zero.\n\n\n\n\n\n\n0x2\n\n\ncpy \n[destRegister] [register]\n\n\nCopies the content of \nregister\n to the specified destination register.\n\n\n\n\n\n\n0x3\n\n\nadd \n[destRegister] [registerA] [registerB]\n\n\nAdds the value of \nregisterB\n to the value of \nregisterA\n. The result is stored in \ndestRegister\n.\n\n\n\n\n\n\n0x4\n\n\nsub \n[destRegister] [registerA] [registerB]\n\n\nSubtracts the value of \nregisterB\n from the value of \nregisterA\n. The result is stored in \ndestRegister\n.\n\n\n\n\n\n\n0x5\n\n\nmul \n[destRegister] [registerA] [registerB]\n\n\nMultiplies the value of \nregisterB\n with the value of \nregisterA\n. The result is stored in \ndestRegister\n.\n\n\n\n\n\n\n0x6\n\n\ndiv \n[destRegister] [registerA] [registerB]\n\n\nDivides the value of \nregisterB\n by the value of \nregisterA\n. The result is stored in \ndestRegister\n. If \nregisterB\n is zero the VM will halt with a \"Division by zero\".\n\n\n\n\n\n\n0x7\n\n\ninv \n[register]\n\n\nInverts the sign of the value that is stored in the specified register. Thre result is stored in the same register.\n\n\n\n\n\n\n0x8\n\n\neql \n[destRegister] [registerA] [registerB]\n\n\nChecks if the value of \nregisterB\n and the value of \nregisterA\n are equal. The result is either \n0\n or \n1\n and is stored in \ndestRegister\n.\n\n\n\n\n\n\n0x9\n\n\nneq \n[destRegister] [registerA] [registerB]\n\n\nChecks if the value of \nregisterB\n and the value of \nregisterA\n are not equal. The result is either \n0\n or \n1\n and is stored in \ndestRegister\n.\n\n\n\n\n\n\n0xA\n\n\ngre \n[destRegister] [registerA] [registerB]\n\n\nChecks if the value of \nregisterA\n is greater than the value of \nregisterB\n. The result is either \n0\n or \n1\n and is stored in \ndestRegister\n.\n\n\n\n\n\n\n0xB\n\n\nles \n[destRegister] [registerA] [registerB]\n\n\nChecks if the value of \nregisterA\n is less than the value of \nregisterB\n. The result is either \n0\n or \n1\n and is stored in \ndestRegister\n\n\n\n\n\n\n0xC\n\n\njmp \n[register] [isAbsolute]\n\n\nJumps the number of in \nregister\n stored instructions backward or forward in the instruction queue relative to the current position if \nisAbsolute\n is zero (default). Otherwise the jump is absolute to the fist instruction (zero-based). If the value is zero then no jump is executed.\n\n\n\n\n\n\n0xD\n\n\nhcl \n[groupId] [functionId]\n\n\nExecutes a function in the host application. The function to call is defined by \ngroupId\n and \nfunctionId\n. For more information on how to use Host Calls see the topic on \nHost Calls\n.\n\n\n\n\n\n\n\n\nTips & Tricks\n\u00b6\n\n\nThis section features a list of useful tips and tricks that can be used to write your own Photon scripts. Some of them are used to imitate the behaviour of a higher level language like C/C++ or Java that support control structures like \nif-statements\n or \nfor-loops\n.\n\n\n\n\nMissing\n\n\nThis section is incomplete and will be changed later. Sorry.\n\n\n\n\nIf-Statement\n\u00b6\n\n\nFor-Loop\n\u00b6",
            "title": "Language"
        },
        {
            "location": "/manual/language/#the-language",
            "text": "The PhotonVM source code language is similar to the Assembly language, as it consists of a series of instructions that are combined to create an executable program. An instruction is defined by the name of the instruction to call and a list of up to three parameters, for example:      instr   param1   param2   param3      Every instruction only operates on the VM registers and has no stack or dynamic memory like other languages. Also an instruction can only take either up to three registers or a single constant as a parameter per instruction, if any are supported for the specific instruction.  Parameters can be of tow types:   Register : Registers are addressed as  reg0 - reg12  or  r0 - r12  Constant value : Constants are represented as  123 . The valid range for constants is [0, 255]   The order of execution is linear, so the first instruction in the source or byte-code will be the first one to be executed (FIFO).",
            "title": "The Language"
        },
        {
            "location": "/manual/language/#comments",
            "text": "The Photon language also supports basic line comments to add notes or documentation to Photon source code. A comment starts with  #  and is completely ignored by the Photon compiler when generating executable byte-code. Multiline comments are not supported.      # This is a comment. \n     inv   reg0 \n\n     inv   reg0   # A comment after an instruction.",
            "title": "Comments"
        },
        {
            "location": "/manual/language/#instructions",
            "text": "As Photon uses only 16-bits to encode an instruction, it has a very limited but powerful set of instructions. The following table shows all instructions that are currently supported:     Op Code  Syntax  Description      0x0  halt  [exitCode]  Halts the execution of the virtual machine immediately. A value of  0  represents success. The host can check the result of the execution. See  VMExitCodes  enumeration for predefined codes.    0x1  set  [destRegister] [value]  Writes a constant value to a specific VM register. To clear a register set it to  0  (zero). Note that by default all registers are reset to zero.    0x2  cpy  [destRegister] [register]  Copies the content of  register  to the specified destination register.    0x3  add  [destRegister] [registerA] [registerB]  Adds the value of  registerB  to the value of  registerA . The result is stored in  destRegister .    0x4  sub  [destRegister] [registerA] [registerB]  Subtracts the value of  registerB  from the value of  registerA . The result is stored in  destRegister .    0x5  mul  [destRegister] [registerA] [registerB]  Multiplies the value of  registerB  with the value of  registerA . The result is stored in  destRegister .    0x6  div  [destRegister] [registerA] [registerB]  Divides the value of  registerB  by the value of  registerA . The result is stored in  destRegister . If  registerB  is zero the VM will halt with a \"Division by zero\".    0x7  inv  [register]  Inverts the sign of the value that is stored in the specified register. Thre result is stored in the same register.    0x8  eql  [destRegister] [registerA] [registerB]  Checks if the value of  registerB  and the value of  registerA  are equal. The result is either  0  or  1  and is stored in  destRegister .    0x9  neq  [destRegister] [registerA] [registerB]  Checks if the value of  registerB  and the value of  registerA  are not equal. The result is either  0  or  1  and is stored in  destRegister .    0xA  gre  [destRegister] [registerA] [registerB]  Checks if the value of  registerA  is greater than the value of  registerB . The result is either  0  or  1  and is stored in  destRegister .    0xB  les  [destRegister] [registerA] [registerB]  Checks if the value of  registerA  is less than the value of  registerB . The result is either  0  or  1  and is stored in  destRegister    0xC  jmp  [register] [isAbsolute]  Jumps the number of in  register  stored instructions backward or forward in the instruction queue relative to the current position if  isAbsolute  is zero (default). Otherwise the jump is absolute to the fist instruction (zero-based). If the value is zero then no jump is executed.    0xD  hcl  [groupId] [functionId]  Executes a function in the host application. The function to call is defined by  groupId  and  functionId . For more information on how to use Host Calls see the topic on  Host Calls .",
            "title": "Instructions"
        },
        {
            "location": "/manual/language/#tips-tricks",
            "text": "This section features a list of useful tips and tricks that can be used to write your own Photon scripts. Some of them are used to imitate the behaviour of a higher level language like C/C++ or Java that support control structures like  if-statements  or  for-loops .   Missing  This section is incomplete and will be changed later. Sorry.",
            "title": "Tips &amp; Tricks"
        },
        {
            "location": "/manual/language/#if-statement",
            "text": "",
            "title": "If-Statement"
        },
        {
            "location": "/manual/language/#for-loop",
            "text": "",
            "title": "For-Loop"
        },
        {
            "location": "/manual/integration-guide/",
            "text": "C++ Integration Guide\n\u00b6\n\n\nThis page describes how the Photon scripting language can be integrated into any C++ project. No additional librarys are required except for the C++ standard library. The process of integrating and customizing Photon with your own project will be described in the following sections.\n\n\nTo use Photon simply include the \nPhotonVM.h\n header file where it is needed. In \none\n of the C++ files write the following line before \n#include \"PhotonVM.h\n:\n\n#define PHOTON_IMPLEMENTATION\n\n\n\nThis will expand the actual implementation of the VM.\n\n\nBuild Options\n\u00b6\n\n\nPhoton provides a set of build options that can be overridden to better fit into your project. Define them before \n#include \"PhotonVM.h\n (or define them globally) to override the default settings. The following table shows all available options:\n\n\n\n\n\n\n\n\nName\n\n\nValues\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPHOTON_MAX_HOST_CALLS\n\n\n1-4096\n\n\n32\n\n\nTotal number of Host-Calls that can be registered at once. This can be reduced if fewer calls are used. The maximum number of calls is: 0xFFF = 4095. Note that one group always consists of 256 functions.\n\n\n\n\n\n\nPHOTON_DEBUG_CALLBACK_ENABLED\n\n\n0-1\n\n\n0\n\n\nEnable or disable the user debug callback on the virtual machine. See the section on \ndebug callbacks\n for more information.\n\n\n\n\n\n\nPHOTON_IS_HOST_CALL_STRICT\n\n\n0-1\n\n\n0\n\n\nEnable or disable strictness of Host-Calls. If enabled and no Host-Call can be found for a hcall instruction the VM will halt, otherwise it will continue.\n\n\n\n\n\n\nPHOTON_COMPILER_ERROR_STRICT\n\n\n0-1\n\n\n0\n\n\nIf enabled then the lexer will stop after it encounters an error, otherwise it will continue.\n\n\n\n\n\n\nPHOTON_NO_COMPILER\n\n\n-\n\n\nundefined\n\n\nDefining this disables the internal Photon byte-code compiler.\n\n\n\n\n\n\nPHOTON_STATIC\n\n\n-\n\n\nundefined\n\n\nDefining this makes the implementation private to the source file that generates it.\n\n\n\n\n\n\nPHOTON_MALLOC_OVERRIDE\n\n\n-\n\n\nundefined\n\n\nDefining this will disable the use of \nmalloc\n and \nfree\n for compiler memory allocation. If this is defined it is also required to define \npho_malloc(size)\n and \npho_free(ptr)\n with custom allocation and deallocation methods.\n\n\n\n\n\n\n\n\nCreating a Virtual Machine\n\u00b6\n\n\nTo create a Photon VM simply create a Virtual Machine with the \nPhtoton\n::\ncreateVirtualMachine\n(\nByteCode\n \nbyteCode\n,\n \nVerbosityLevel\n \nverbosity\n)\n function and pass it the byte-code to execute. Additionally any Host Calls can be registered before calling \nPhoton\n::\nrun\n(\nVirtualMachine\n*\n \nvm\n)\n to kick off the execution.\n\n\nPhoton\n::\nVirtualMachine\n \nvm\n \n=\n \nPhoton\n::\ncreateVirtualMachine\n(\nbyteCode\n,\n \nPhoton\n::\nVerbosityLevelAll\n);\n\n\n// Register additional Host Calls here...\n\n\nPhoton\n::\nrun\n(\n&\nvm\n);\n\n\n\n\n\nCompiling Byte-Code\n\u00b6\n\n\nTo execute anything on the VM byte-code is required which is a binary list of instructions that tell the VM what to do. As it is pretty difficult to write raw byte-code Photon defines a language that can be compiled into actual executable byte-code. For more information about the syntax of the language see the \nlanguage documentation\n.\n\n\n\n\nTip\n\n\nIf byte-code is compiled offline instead and no compiler is required then consider disabling this feature altogether. See the \nbuild options\n for more information.\n\n\n\n\nTo compile any string of Photon source code into byte-code Phtoton provides a \nPhoton::compile(char* source, const char* fileName)\n function which gets passed the source code string to compile and an optional file name for debug output.\nThe resulting byte-code will always be accepted by the VM but the compiled result may actually be different from the specified input source.\n\n\nPhoton\n::\nByteCode\n \nbyteCode\n \n=\n \nPhoton\n::\ncompile\n(\nsourceString\n,\n \n\"SomeFile.pho\"\n);\n\n\n\n\n\nTo check if any instruction was generated at all pass the byte-code to the \nPhoton::isByteCodeValid(ByteCode* byteCode)\n function and check the result.\nTo verify the actual output of the compiler use debug callbacks as described in \nthis section\n.\n\n\nAfter the VM has finished executing and the byte-code is no longer needed it is recommended to free it. If the internal compiler generated the byte-code then call \nPhoton::releaseByteCode(ByteCode* byteCode)\n to free it.\n\n\n\n\nTip\n\n\nPhoton does not support loading byte-code or source code from file as this makes the library way more portable. If this is required simply \nfread/fwrite\n a header block containing metadata about the byte-code and read/write the actual data as a blob.\n\n\n\n\nHost Calls\n\u00b6\n\n\nPhoton's instruction set is very minimal so sometimes it is required to extend it with new functionality that is not existing in Photon. So how does this work? Host calls for the rescue!\n\n\nHost calls live in the host application (as the name implies) and can be called from a Photon script using the \nhcl\n instruction. They have the abillity to modify the VM registers and perform operations on them that are not possible in raw Photon instructions.\n\n\nIn this example a simple call is created that takes the value at \nreg0\n, then squares it and  stores it in \nreg1\n.\nCreating a new Host Call is simple, first a call needs to be defined in the host by using the \nHostCallback(name)\n macro:\n\nHostCallback\n(\nsquareValue\n)\n\n\n{\n\n    \n// Get the input of the value to compute from the reg0 register.\n\n    \nPhoton\n::\nRegisterType\n \nvalue\n \n=\n \nregisters\n[\nPhoton\n::\nReg0\n];\n\n\n    \n// Compute the resulting output.\n\n    \nvalue\n \n=\n \nvalue\n \n*\n \nvalue\n;\n\n\n    \n// Store the result in the reg1 register.\n\n    \nregisters\n[\nPhoton\n::\nReg1\n]\n \n=\n \nvalue\n;\n\n\n}\n\n\n\n\nNow the call needs to be registered with an instance of the VM. To do this a group ID and function ID is required.\n\n\n\n\nGroup ID\n: Used to group a number of functions together (mostly for organisation purposes). A group can contain up to 256 different functions. Ranges from [0, 15]\n\n\nFunction ID\n: Defines the index of the function in a specific group. Ranges from [0, 255]\n\n\n\n\nUp to \n4096\n functions can be registered at the same time (total of all groups) and all can be callable via the byte-code. This number can be adjusted if fewer functions are used by the byte code. \n\n\nconst\n \nuint8_t\n \nHC_GROUP_DEFAULT\n \n=\n \n0\n;\n\n\nconst\n \nuint8_t\n \nHC_FUNCTION_SQUARE\n \n=\n \n2\n;\n\n\nPhoton\n::\nregisterHostCall\n(\n&\nvm\n,\n \nsqareValue\n,\n \nHC_GROUP_DEFAULT\n,\n \nHC_FUNCTION_SQUARE\n);\n\n\n\n\n\nNow any script that runs on the VM can now call this function using the following instructions:\n\nset\n \nreg0\n \n2\n\n\nhcl\n \n0\n \n2\n\n\n\n\n\n\nTip\n\n\nThe maximum number of Host Calls can be changed by defining \nPHOTON_MAX_HOST_CALLS\n. See the \nbuild options\n for more info.\n\n\n\n\nDebug Callbacks\n\u00b6\n\n\nDebug callbacks can be useful when debugging any Photon script. They report the decoded instruction and the current state of all registers after the VM has exeuted the instruction. This information can be used to track bugs in Photon scripts. For this feature to work the \nPHOTON_DEBUG_CALLBACK_ENABLED\n build option must be enabled. \n\n\nFor ease of use the \nDebugCallback(name)\n macro can be used to define a callback function.\n\n\n\n\nAttention\n\n\nNeither the instruction that was executed nor the registers themselves can be modified by the callback at any time.\n\n\n\n\nThe following example shows the use of a custom callback to print the last executed instruction and current value of the \nreg0\n register to the standard output:\n\n\nDebugCallback\n(\nmyCallback\n)\n\n\n{\n\n    \nprintf\n(\n\"Instruction op code: %d, reg0=%d\n\\n\n\"\n,\n \ninstruction\n->\nopCode\n,\n \nregisters\n[\nPhoton\n::\nReg0\n]);\n\n\n}\n\n\n\n\n\nFinally the callback needs to be registered with a virtual machine using the \nsetDebugCallback\n function.\nOnly one callback can be set to one VM instance at a time.\n\n\nPhoton\n::\nsetDebugCallback\n(\n&\nvm\n,\n \nmyCallback\n);",
            "title": "Integration Guide"
        },
        {
            "location": "/manual/integration-guide/#c-integration-guide",
            "text": "This page describes how the Photon scripting language can be integrated into any C++ project. No additional librarys are required except for the C++ standard library. The process of integrating and customizing Photon with your own project will be described in the following sections.  To use Photon simply include the  PhotonVM.h  header file where it is needed. In  one  of the C++ files write the following line before  #include \"PhotonVM.h : #define PHOTON_IMPLEMENTATION  \nThis will expand the actual implementation of the VM.",
            "title": "C++ Integration Guide"
        },
        {
            "location": "/manual/integration-guide/#build-options",
            "text": "Photon provides a set of build options that can be overridden to better fit into your project. Define them before  #include \"PhotonVM.h  (or define them globally) to override the default settings. The following table shows all available options:     Name  Values  Default  Description      PHOTON_MAX_HOST_CALLS  1-4096  32  Total number of Host-Calls that can be registered at once. This can be reduced if fewer calls are used. The maximum number of calls is: 0xFFF = 4095. Note that one group always consists of 256 functions.    PHOTON_DEBUG_CALLBACK_ENABLED  0-1  0  Enable or disable the user debug callback on the virtual machine. See the section on  debug callbacks  for more information.    PHOTON_IS_HOST_CALL_STRICT  0-1  0  Enable or disable strictness of Host-Calls. If enabled and no Host-Call can be found for a hcall instruction the VM will halt, otherwise it will continue.    PHOTON_COMPILER_ERROR_STRICT  0-1  0  If enabled then the lexer will stop after it encounters an error, otherwise it will continue.    PHOTON_NO_COMPILER  -  undefined  Defining this disables the internal Photon byte-code compiler.    PHOTON_STATIC  -  undefined  Defining this makes the implementation private to the source file that generates it.    PHOTON_MALLOC_OVERRIDE  -  undefined  Defining this will disable the use of  malloc  and  free  for compiler memory allocation. If this is defined it is also required to define  pho_malloc(size)  and  pho_free(ptr)  with custom allocation and deallocation methods.",
            "title": "Build Options"
        },
        {
            "location": "/manual/integration-guide/#creating-a-virtual-machine",
            "text": "To create a Photon VM simply create a Virtual Machine with the  Phtoton :: createVirtualMachine ( ByteCode   byteCode ,   VerbosityLevel   verbosity )  function and pass it the byte-code to execute. Additionally any Host Calls can be registered before calling  Photon :: run ( VirtualMachine *   vm )  to kick off the execution.  Photon :: VirtualMachine   vm   =   Photon :: createVirtualMachine ( byteCode ,   Photon :: VerbosityLevelAll );  // Register additional Host Calls here...  Photon :: run ( & vm );",
            "title": "Creating a Virtual Machine"
        },
        {
            "location": "/manual/integration-guide/#compiling-byte-code",
            "text": "To execute anything on the VM byte-code is required which is a binary list of instructions that tell the VM what to do. As it is pretty difficult to write raw byte-code Photon defines a language that can be compiled into actual executable byte-code. For more information about the syntax of the language see the  language documentation .   Tip  If byte-code is compiled offline instead and no compiler is required then consider disabling this feature altogether. See the  build options  for more information.   To compile any string of Photon source code into byte-code Phtoton provides a  Photon::compile(char* source, const char* fileName)  function which gets passed the source code string to compile and an optional file name for debug output.\nThe resulting byte-code will always be accepted by the VM but the compiled result may actually be different from the specified input source.  Photon :: ByteCode   byteCode   =   Photon :: compile ( sourceString ,   \"SomeFile.pho\" );   To check if any instruction was generated at all pass the byte-code to the  Photon::isByteCodeValid(ByteCode* byteCode)  function and check the result.\nTo verify the actual output of the compiler use debug callbacks as described in  this section .  After the VM has finished executing and the byte-code is no longer needed it is recommended to free it. If the internal compiler generated the byte-code then call  Photon::releaseByteCode(ByteCode* byteCode)  to free it.   Tip  Photon does not support loading byte-code or source code from file as this makes the library way more portable. If this is required simply  fread/fwrite  a header block containing metadata about the byte-code and read/write the actual data as a blob.",
            "title": "Compiling Byte-Code"
        },
        {
            "location": "/manual/integration-guide/#host-calls",
            "text": "Photon's instruction set is very minimal so sometimes it is required to extend it with new functionality that is not existing in Photon. So how does this work? Host calls for the rescue!  Host calls live in the host application (as the name implies) and can be called from a Photon script using the  hcl  instruction. They have the abillity to modify the VM registers and perform operations on them that are not possible in raw Photon instructions.  In this example a simple call is created that takes the value at  reg0 , then squares it and  stores it in  reg1 .\nCreating a new Host Call is simple, first a call needs to be defined in the host by using the  HostCallback(name)  macro: HostCallback ( squareValue )  { \n     // Get the input of the value to compute from the reg0 register. \n     Photon :: RegisterType   value   =   registers [ Photon :: Reg0 ]; \n\n     // Compute the resulting output. \n     value   =   value   *   value ; \n\n     // Store the result in the reg1 register. \n     registers [ Photon :: Reg1 ]   =   value ;  }   Now the call needs to be registered with an instance of the VM. To do this a group ID and function ID is required.   Group ID : Used to group a number of functions together (mostly for organisation purposes). A group can contain up to 256 different functions. Ranges from [0, 15]  Function ID : Defines the index of the function in a specific group. Ranges from [0, 255]   Up to  4096  functions can be registered at the same time (total of all groups) and all can be callable via the byte-code. This number can be adjusted if fewer functions are used by the byte code.   const   uint8_t   HC_GROUP_DEFAULT   =   0 ;  const   uint8_t   HC_FUNCTION_SQUARE   =   2 ;  Photon :: registerHostCall ( & vm ,   sqareValue ,   HC_GROUP_DEFAULT ,   HC_FUNCTION_SQUARE );   Now any script that runs on the VM can now call this function using the following instructions: set   reg0   2  hcl   0   2    Tip  The maximum number of Host Calls can be changed by defining  PHOTON_MAX_HOST_CALLS . See the  build options  for more info.",
            "title": "Host Calls"
        },
        {
            "location": "/manual/integration-guide/#debug-callbacks",
            "text": "Debug callbacks can be useful when debugging any Photon script. They report the decoded instruction and the current state of all registers after the VM has exeuted the instruction. This information can be used to track bugs in Photon scripts. For this feature to work the  PHOTON_DEBUG_CALLBACK_ENABLED  build option must be enabled.   For ease of use the  DebugCallback(name)  macro can be used to define a callback function.   Attention  Neither the instruction that was executed nor the registers themselves can be modified by the callback at any time.   The following example shows the use of a custom callback to print the last executed instruction and current value of the  reg0  register to the standard output:  DebugCallback ( myCallback )  { \n     printf ( \"Instruction op code: %d, reg0=%d \\n \" ,   instruction -> opCode ,   registers [ Photon :: Reg0 ]);  }   Finally the callback needs to be registered with a virtual machine using the  setDebugCallback  function.\nOnly one callback can be set to one VM instance at a time.  Photon :: setDebugCallback ( & vm ,   myCallback );",
            "title": "Debug Callbacks"
        },
        {
            "location": "/reference/vm-architecture/",
            "text": "VM Architecture\n\u00b6\n\n\nThis section describes the architecture that is used to create the core of the Photon VM.\nThe core consists of a fixed set of registers that the compiled byte-code can operate on. The following graphic shows an overview of the core architecture of the VM.\n\n\n\n\n\n\nDanger\n\n\nNeed to rework the graphic!\n\n\n\n\nRegisters\n\u00b6\n\n\nPhoton's core consists of \n13\n different registers of which \n12\n can be used by the user code or as result registers for more complex host calls. The minimum value that a register can hold is \n-2\n32\n and the maximum is \n2\n32\n-1\n. The registers are grouped into two categories: \n\n\n\n\n\n\nGeneral use registers. These range from \nreg0\n to \nreg11\n and are only used by the user code and no external modification should be made to these registers other than the instructions that are defined by the user.\n\n\n\n\n\n\nSpecial purpose registers. The register \nreg12\n (aka. \nlocal\n) is only used for short-time storage because it is \nnot\n guaranteed that the value will not get overwritten by one of the following instructions. Use it to transfer data from one instruction to the next.\n\n\n\n\n\n\nNote that the VM does \nnot\n support string and floating-point types. If string types are needed, for example as identifier, then use string hashing at compile time level or plain indices instead.\n\n\n\n\nInfo\n\n\nPhoton byte-code can not encode values that are greater than 255 or negative but registers can, for example as the result of an addition or using the \ninv\n instruction.\n\n\n\n\nInstruction Encoding\n\u00b6\n\n\nInstruction codes in Photon are encoded into 16-bit unsigned integer values. These contain all data of an instruction so the VM is able to decode and execute it on the fly.\n\n\nConstants are encoded in the last 8-bits of the instruction, so the VM supports values in a range from \n0-255\n. The data gets placed from the last-significant-bit position:\n\n\n| 7| 6| 5| 4| 3| 2| 1| 0|\n\n\n\n\n\nParameters are stored using 4-bits for all:\n\n\n|11|10| 9| 8|\n\n\n\n\n\nThe most significant 4 bits are used to store the instruction type:\n\n\n|15|14|13|12|\n\n\n\n\n\nAs an example, an instruction that loads a constant value into a VM register would be represented as following:\n\n\nset      reg2   30\n-------------------------\n0001     0010   00011110 => 0x121E\n\n\n\n\n\nMany instructions use three parameters instead of two. The 8-bit constant section then gets split into two 4-bit sections. This works because registers \nnever\n exceed the \n[0x0, 0xF]\n range so they can be stored using only 4-bits.\n\n\nHalt Instruction\n\u00b6\n\n\nThe halt instruction is similar to C/C++ \nreturn\n or \nexit\n()\n. It indicates an errors in the VM byte-code that can either be emitted by the VM itself, e.g. by an \nout of bounds jump\n or a \ndivide by zero\n, or from user code by using the \nhalt\n instruction. By default every script will contain a halt at the end with a parameter of \n0\n, though it is advised to explicitly halt the VM at the end of script execution.\n\n\nPhoton defines a fixed number of exit codes that can be emitted by the VM itself to report internal errors which should halt the VM immediately. These codes are encoded in the most significant bits while user errors should be encoded in the least significant bits to avoid conflicts. The following table shows all internal exit codes:\n\n\n\n\n\n\n\n\nExit Code\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n0\n\n\nExitCodeSuccess\n\n\nSignals sucessfull execution of the code.\n\n\n\n\n\n\n251\n\n\nExitCodeHaltRequested\n\n\nSignals that the VM should be halted by a user request. This does not mean that the VM has finished execution of the byte-code.\n\n\n\n\n\n\n252\n\n\nExitCodeDivideByZero\n\n\nSignals a division by zero error.\n\n\n\n\n\n\n253\n\n\nExitCodeJumpOutOfBounds\n\n\nSignals that the offset of a jump instruction is out of bounds.\n\n\n\n\n\n\n254\n\n\nExitCodeRegisterFault\n\n\nSignals that the byte-code tried to access an invalid register.\n\n\n\n\n\n\n255\n\n\nExitCodeInvalidHostCall\n\n\nSignals that a host call function was requested but could not be resolved. This will only be signalled if \nPHOTON_IS_HOST_CALL_STRICT\n is enabled.\n\n\n\n\n\n\n\n\nCode Execution\n\u00b6\n\n\nPhoton byte-code is stored in a contiguous block of memory as a list of packed 16-bit instruction codes. Execution of this byte-code list will always start at the first instruction and it is guaranteed that all registers are cleared to zero before the first instruction gets executed. The VM will run until either a halt instruction is executed or no more instructions are left to execute. In the latter case success of the execution is assumed. Furthermore when executing any byte-code the implementation will \nnever\n assume that the actual byte-code is correct and should handle invalid execution by halting.\n\n\nIf debug callbacks are used then they get called \nafter\n the instruction got executed.",
            "title": "VM Architecture"
        },
        {
            "location": "/reference/vm-architecture/#vm-architecture",
            "text": "This section describes the architecture that is used to create the core of the Photon VM.\nThe core consists of a fixed set of registers that the compiled byte-code can operate on. The following graphic shows an overview of the core architecture of the VM.    Danger  Need to rework the graphic!",
            "title": "VM Architecture"
        },
        {
            "location": "/reference/vm-architecture/#registers",
            "text": "Photon's core consists of  13  different registers of which  12  can be used by the user code or as result registers for more complex host calls. The minimum value that a register can hold is  -2 32  and the maximum is  2 32 -1 . The registers are grouped into two categories:     General use registers. These range from  reg0  to  reg11  and are only used by the user code and no external modification should be made to these registers other than the instructions that are defined by the user.    Special purpose registers. The register  reg12  (aka.  local ) is only used for short-time storage because it is  not  guaranteed that the value will not get overwritten by one of the following instructions. Use it to transfer data from one instruction to the next.    Note that the VM does  not  support string and floating-point types. If string types are needed, for example as identifier, then use string hashing at compile time level or plain indices instead.   Info  Photon byte-code can not encode values that are greater than 255 or negative but registers can, for example as the result of an addition or using the  inv  instruction.",
            "title": "Registers"
        },
        {
            "location": "/reference/vm-architecture/#instruction-encoding",
            "text": "Instruction codes in Photon are encoded into 16-bit unsigned integer values. These contain all data of an instruction so the VM is able to decode and execute it on the fly.  Constants are encoded in the last 8-bits of the instruction, so the VM supports values in a range from  0-255 . The data gets placed from the last-significant-bit position:  | 7| 6| 5| 4| 3| 2| 1| 0|  Parameters are stored using 4-bits for all:  |11|10| 9| 8|  The most significant 4 bits are used to store the instruction type:  |15|14|13|12|  As an example, an instruction that loads a constant value into a VM register would be represented as following:  set      reg2   30\n-------------------------\n0001     0010   00011110 => 0x121E  Many instructions use three parameters instead of two. The 8-bit constant section then gets split into two 4-bit sections. This works because registers  never  exceed the  [0x0, 0xF]  range so they can be stored using only 4-bits.",
            "title": "Instruction Encoding"
        },
        {
            "location": "/reference/vm-architecture/#halt-instruction",
            "text": "The halt instruction is similar to C/C++  return  or  exit () . It indicates an errors in the VM byte-code that can either be emitted by the VM itself, e.g. by an  out of bounds jump  or a  divide by zero , or from user code by using the  halt  instruction. By default every script will contain a halt at the end with a parameter of  0 , though it is advised to explicitly halt the VM at the end of script execution.  Photon defines a fixed number of exit codes that can be emitted by the VM itself to report internal errors which should halt the VM immediately. These codes are encoded in the most significant bits while user errors should be encoded in the least significant bits to avoid conflicts. The following table shows all internal exit codes:     Exit Code  Name  Description      0  ExitCodeSuccess  Signals sucessfull execution of the code.    251  ExitCodeHaltRequested  Signals that the VM should be halted by a user request. This does not mean that the VM has finished execution of the byte-code.    252  ExitCodeDivideByZero  Signals a division by zero error.    253  ExitCodeJumpOutOfBounds  Signals that the offset of a jump instruction is out of bounds.    254  ExitCodeRegisterFault  Signals that the byte-code tried to access an invalid register.    255  ExitCodeInvalidHostCall  Signals that a host call function was requested but could not be resolved. This will only be signalled if  PHOTON_IS_HOST_CALL_STRICT  is enabled.",
            "title": "Halt Instruction"
        },
        {
            "location": "/reference/vm-architecture/#code-execution",
            "text": "Photon byte-code is stored in a contiguous block of memory as a list of packed 16-bit instruction codes. Execution of this byte-code list will always start at the first instruction and it is guaranteed that all registers are cleared to zero before the first instruction gets executed. The VM will run until either a halt instruction is executed or no more instructions are left to execute. In the latter case success of the execution is assumed. Furthermore when executing any byte-code the implementation will  never  assume that the actual byte-code is correct and should handle invalid execution by halting.  If debug callbacks are used then they get called  after  the instruction got executed.",
            "title": "Code Execution"
        }
    ]
}