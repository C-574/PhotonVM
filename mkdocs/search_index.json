{
    "docs": [
        {
            "location": "/",
            "text": "Home\n\n\n\n\nPhotonVM is a register-based virtual machine that is written in C++ with the goals to be very small, in code size and byte code size, while still being a fully functional interpreted language. It was mostly written for educational purposes (and for fun, of course). \n\n\nThis site contains all documentation about the Photon VM. To \nget started\n see the \nIntegration Guide\n.\n\n\nFeatures\n\n\nSome of the features of Photon are:\n\n\n\n\nEasy to integrate (\nheader-only library\n) with customizable interface for the host application\n\n\nNo external dependencies (\nexcept\n for the C/C++ standard library and a C++11 compatible compiler)\n\n\nSmall but fully functional instruction set\n\n\nGenerates very small byte-code output (16-bits per instruction)\n\n\nCan compile and run Photon source code or pre-compiled byte-code\n\n\nNo dynamic memory allocation at byte-code runtime  \n\n\n\n\nThe name \nPhoton\n was chosen because every instruction that can be executed is very small and lightweight, as they  are packed into only 16-bits. \n\n\nThe code that the Photon compiler packs into a executable format is very Assembly-like and linear. Also the VM is portable between different operating systems (currently only tested on Windows 7/10 and Linux Ubuntu 14.04 LTS).\n\n\nExamples\n\n\n\n\nThis section shows a list of examples. These examples can also be found in the \n/examples\n directory of the VM.\n\n\nHello World\n\n\nThis simple example is kind of the \n\"Hello World\"\n of Photon. It shows how to add two values together and print the resulting value to the screen.\n\n\n-- Store two values in two registers for addition.\nsetreg reg0 #3\nsetreg reg1 #7\n\n-- Let the VM add both registers together and store the result in another register, 'local' in this case.\naddreg local reg0 reg1\n\n-- Call the host application to output the calculated value.\nhcall $0 #2\n\n-- Halt the execution of the VM.\nhalt\n\n\n\nFibonacci\n\n\nThis example shows how to compute the Fibonacci sequence to a specific number of iterations.\nThis is a pretty complex example as it makes use of the \njump\n instruction and the special \nlocal\n register to imitate control structures such as \nwhile-loops\n and \nif-statements\n. \n\n\nThe number of iterations of the algorithm is defined by the value of the \nreg0\n register while result of the Fibonacci sequence computation is stored in the \nreg1\n register. The script in the example directory also prints the result to the host application's output which is ignored here for simplicity.\n\n\n-- Defines the iteration count of the algorithm.\nsetreg reg0 #6\n\n-- Define the variables that are used to compute the sequence.\nsetreg reg1 #0\nsetreg tmp0 #0\nsetreg tmp1 #1\n\n\n-- tmp3 = instruction count of loop-block (lS).\nsetreg tmp3 #9\n-- tmp2 = start index of loop (i).\nsetreg tmp2 #2\n\n-- while(i < N) ...\ngrtreg local tmp2 reg0\nmulreg local local tmp3\njump local\n-- BEGIN - While\naddreg reg1 tmp0 tmp1\ncpyreg tmp0 tmp1\ncpyreg tmp1 reg1\n\n-- Increment the loop counter 'i'.\nsetreg local #1\naddreg tmp2 tmp2 local\n-- jump back to the loop-head.\nsetreg local #10\ninvreg local\njump local\n-- END - While\n\nhalt",
            "title": "Home"
        },
        {
            "location": "/#home",
            "text": "PhotonVM is a register-based virtual machine that is written in C++ with the goals to be very small, in code size and byte code size, while still being a fully functional interpreted language. It was mostly written for educational purposes (and for fun, of course).   This site contains all documentation about the Photon VM. To  get started  see the  Integration Guide .",
            "title": "Home"
        },
        {
            "location": "/#features",
            "text": "Some of the features of Photon are:   Easy to integrate ( header-only library ) with customizable interface for the host application  No external dependencies ( except  for the C/C++ standard library and a C++11 compatible compiler)  Small but fully functional instruction set  Generates very small byte-code output (16-bits per instruction)  Can compile and run Photon source code or pre-compiled byte-code  No dynamic memory allocation at byte-code runtime     The name  Photon  was chosen because every instruction that can be executed is very small and lightweight, as they  are packed into only 16-bits.   The code that the Photon compiler packs into a executable format is very Assembly-like and linear. Also the VM is portable between different operating systems (currently only tested on Windows 7/10 and Linux Ubuntu 14.04 LTS).",
            "title": "Features"
        },
        {
            "location": "/#examples",
            "text": "This section shows a list of examples. These examples can also be found in the  /examples  directory of the VM.",
            "title": "Examples"
        },
        {
            "location": "/#hello-world",
            "text": "This simple example is kind of the  \"Hello World\"  of Photon. It shows how to add two values together and print the resulting value to the screen.  -- Store two values in two registers for addition.\nsetreg reg0 #3\nsetreg reg1 #7\n\n-- Let the VM add both registers together and store the result in another register, 'local' in this case.\naddreg local reg0 reg1\n\n-- Call the host application to output the calculated value.\nhcall $0 #2\n\n-- Halt the execution of the VM.\nhalt",
            "title": "Hello World"
        },
        {
            "location": "/#fibonacci",
            "text": "This example shows how to compute the Fibonacci sequence to a specific number of iterations.\nThis is a pretty complex example as it makes use of the  jump  instruction and the special  local  register to imitate control structures such as  while-loops  and  if-statements .   The number of iterations of the algorithm is defined by the value of the  reg0  register while result of the Fibonacci sequence computation is stored in the  reg1  register. The script in the example directory also prints the result to the host application's output which is ignored here for simplicity.  -- Defines the iteration count of the algorithm.\nsetreg reg0 #6\n\n-- Define the variables that are used to compute the sequence.\nsetreg reg1 #0\nsetreg tmp0 #0\nsetreg tmp1 #1\n\n\n-- tmp3 = instruction count of loop-block (lS).\nsetreg tmp3 #9\n-- tmp2 = start index of loop (i).\nsetreg tmp2 #2\n\n-- while(i < N) ...\ngrtreg local tmp2 reg0\nmulreg local local tmp3\njump local\n-- BEGIN - While\naddreg reg1 tmp0 tmp1\ncpyreg tmp0 tmp1\ncpyreg tmp1 reg1\n\n-- Increment the loop counter 'i'.\nsetreg local #1\naddreg tmp2 tmp2 local\n-- jump back to the loop-head.\nsetreg local #10\ninvreg local\njump local\n-- END - While\n\nhalt",
            "title": "Fibonacci"
        },
        {
            "location": "/manual/language/",
            "text": "The Language\n\n\n\n\nThe PhotonVM source code language is similar to the Assembly language, as it consists of a series of instructions that are combined to create an executable program. An instruction is defined by the name of the instruction to call and a list of up to three parameters, for example:\n\n\ninstr param1 param2 param3/value\n\n\n\nEvery instruction \nonly\n operates on the VM registers and has no stack like other languages, e.g. Java. Also an instruction can only take \none constant value\n as a parameter per instruction, if any are supported for the specific instruction.\n\n\nParameters can be of different types. The following list shows all parameters types that are supported by the language:\n\n\n\n\nRegister\n: Registers are addressed as \nreg0 - reg5, tmp0 - tmp5\n and special register \n\"local\"\n\n\nConstant value\n: Scalar and constant values are represented as \n#123\n. They can range from \n0\n to \n255\n and can not be negative.\n\n\nGroup Id\n: Group ids are used to access a specific Host-Call function-group and have the prefix \n\"$\"\n\n\n\n\nComments\n\n\nThe Photon language also supports basic line comments to add notes or documentation to Photon source code. A comment starts with \n--\n and is completely ignored by the Photon compiler when generating executable byte-code. Currently it is \nnot\n allowed to place comments in the same line as an uncommented instruction, it is only valid on a single line:\n\n\ninvreg reg0 -- Wrong!\n\n-- Right. This is a comment.\ninvreg reg0\n\n\n\nInstructions\n\n\nAs Photon uses only 16-bits to encode an instruction, it has a very limited but powerful set of instructions. The following table shows all instructions that are currently supported:\n\n\n\n    \n\n        \nInstruction Code\n\n        \nSyntax\n\n        \nDescription\n\n    \n\n    \n\n        \n0x00\n\n        \nhalt\n \n[value]\n\n        \nHalts the execution of the virtual machine immediately. The default exit code of \n0\n represents success. The host-code can check the result of the execution. See \nVMExitCodes\n enumeration for predefined codes.\n\n    \n\n    \n\n        \n0x01\n\n        \nsetreg\n \n[destRegister] [value]\n\n        \nWrites a constant value to a specific VM register. To clear a register set it to \n0\n (zero). Note that by default all registers are reset to zero.\n\n    \n\n    \n\n        \n0x02\n\n        \ncpyreg\n \n[destRegister] [register]\n\n        \nCopies the content of \nregister\n to the specified destination register.\n\n    \n\n    \n\n        \n0x03\n\n        \naddreg\n \n[destRegister] [registerA] [registerB]\n\n        \nAdds the value of \nregisterB\n to the value of \nregisterA\n. The result is stored in \ndestRegister\n.\n\n    \n\n    \n\n        \n0x04\n\n        \nsubreg\n \n[destRegister] [registerA] [registerB]\n\n        \nSubtracts the value of \nregisterB\n from the value of \nregisterA\n. The result is stored in \ndestRegister\n.\n\n    \n\n    \n\n        \n0x05\n\n        \nmulreg\n \n[destRegister] [registerA] [registerB]\n\n        \nMultiplies the value of \nregisterB\n with the value of \nregisterA\n. The result is stored in \ndestRegister\n.\n\n    \n\n    \n\n        \n0x06\n\n        \ndivreg\n \n[destRegister] [registerA] [registerB]\n\n        \nDivides the value of \nregisterB\n by the value of \nregisterA\n. The result is stored in \ndestRegister\n.\n\n    \n\n    \n\n        \n0x07\n\n        \ninvreg\n \n[register]\n\n        \nInverts the sign of the value that is stored in the specified register. Thre result is stored in the same register.\n\n    \n\n    \n\n        \n0x08\n\n        \neqreg\n \n[destRegister] [registerA] [registerB]\n\n        \nChecks if the value of \nregisterB\n and the value of \nregisterA\n are equal. The result is either \n0\n or \n1\n and   is stored in \ndestRegister\n.\n\n    \n\n    \n\n        \n0x09\n\n        \nneqreg\n \n[destRegister] [registerA] [registerB]\n\n        \nChecks if the value of \nregisterB\n and the value of \nregisterA\n are \nnot\n equal. The result is either \n0\n or \n1\n and is stored in \ndestRegister\n.\n\n    \n\n    \n\n        \n0x0A\n\n        \ngrtreg\n \n[destRegister] [registerA] [registerB]\n\n        \nChecks if the value of \nregisterA\n is grater than the value of \nregisterB\n. The result is either \n0\n or \n1\n and is stored in \ndestRegister\n.\n\n    \n\n    \n\n        \n0x0B\n\n        \nletreg\n \n[destRegister] [registerA] [registerB]\n\n        \nChecks if the value of \nregisterA\n is less than the value of \nregisterB\n. The result is either \n0\n or \n1\n and is stored in \ndestRegister\n.\n\n    \n\n    \n\n        \n0x0C\n\n        \njump\n \n[register] [isAbsolute]\n\n        \nJumps the number of \nregister\n instructions backwards or forwards in the instruction queue relative to the current position if \nisAbsolute\n is zero (default). Otherwise the jump is absolute to the fist instruction (zero-based). If the value is \nzero\n then no jump is executed.\n\n    \n\n    \n\n        \n0x0D\n\n        \nhcall\n \n[groupId] [functionId]\n\n        \nExecutes a function in the host-application. The function to call is defined by the group-id and the function-id. For more information on how to use Host-Calls see the topic on \nHost Calls\n.\n\n    \n\n\n\n\n\nHost-Calls\n\n\nA \nHost-Call\n is a function that resists in the C++ code of the host-application and that can be called by the VM via the \nhcall\n instruction. This instruction takes two parameters to determine the exact function to execute.\n\n\nThe first parameter is the \nGroup-Id\n, this is used to group a number of functions together (mostly for organisation purposes). A group can contain up to 256 different functions.\n\n\nThe second parameter is the \nFunction-Id\n which defines the index of the function in the specific group. Up to \n4096\n functions can be registered at the same time (total of all groups) and all can be callable via the byte-code, this number can be adjusted if fewer functions are used by the byte-code. \n\n\nThe byte-code can call the function via:\n\n\n-- Group-Id: 0 Function-Id: 1\nhcall $0 #1\n\n\n\nFor more information about \nhow to implement a custom Host-Call\n see the \nIntegration Guide\n\n\nTips & Tricks\n\n\nThis section features a list of useful tips and tricks that can be used to write your own Photon scripts. Some of them are used to imitate the behaviour of a higher level language like C/C++ or Java that support control structures like \nif-statements\n or \nfor-loops\n.\n\n\nIf-Statement\n\n\nToDo\n   \n\n\nFor-Loop\n\n\nToDo",
            "title": "Language"
        },
        {
            "location": "/manual/language/#the-language",
            "text": "The PhotonVM source code language is similar to the Assembly language, as it consists of a series of instructions that are combined to create an executable program. An instruction is defined by the name of the instruction to call and a list of up to three parameters, for example:  instr param1 param2 param3/value  Every instruction  only  operates on the VM registers and has no stack like other languages, e.g. Java. Also an instruction can only take  one constant value  as a parameter per instruction, if any are supported for the specific instruction.  Parameters can be of different types. The following list shows all parameters types that are supported by the language:   Register : Registers are addressed as  reg0 - reg5, tmp0 - tmp5  and special register  \"local\"  Constant value : Scalar and constant values are represented as  #123 . They can range from  0  to  255  and can not be negative.  Group Id : Group ids are used to access a specific Host-Call function-group and have the prefix  \"$\"",
            "title": "The Language"
        },
        {
            "location": "/manual/language/#comments",
            "text": "The Photon language also supports basic line comments to add notes or documentation to Photon source code. A comment starts with  --  and is completely ignored by the Photon compiler when generating executable byte-code. Currently it is  not  allowed to place comments in the same line as an uncommented instruction, it is only valid on a single line:  invreg reg0 -- Wrong!\n\n-- Right. This is a comment.\ninvreg reg0",
            "title": "Comments"
        },
        {
            "location": "/manual/language/#instructions",
            "text": "As Photon uses only 16-bits to encode an instruction, it has a very limited but powerful set of instructions. The following table shows all instructions that are currently supported:  \n     \n         Instruction Code \n         Syntax \n         Description \n     \n     \n         0x00 \n         halt   [value] \n         Halts the execution of the virtual machine immediately. The default exit code of  0  represents success. The host-code can check the result of the execution. See  VMExitCodes  enumeration for predefined codes. \n     \n     \n         0x01 \n         setreg   [destRegister] [value] \n         Writes a constant value to a specific VM register. To clear a register set it to  0  (zero). Note that by default all registers are reset to zero. \n     \n     \n         0x02 \n         cpyreg   [destRegister] [register] \n         Copies the content of  register  to the specified destination register. \n     \n     \n         0x03 \n         addreg   [destRegister] [registerA] [registerB] \n         Adds the value of  registerB  to the value of  registerA . The result is stored in  destRegister . \n     \n     \n         0x04 \n         subreg   [destRegister] [registerA] [registerB] \n         Subtracts the value of  registerB  from the value of  registerA . The result is stored in  destRegister . \n     \n     \n         0x05 \n         mulreg   [destRegister] [registerA] [registerB] \n         Multiplies the value of  registerB  with the value of  registerA . The result is stored in  destRegister . \n     \n     \n         0x06 \n         divreg   [destRegister] [registerA] [registerB] \n         Divides the value of  registerB  by the value of  registerA . The result is stored in  destRegister . \n     \n     \n         0x07 \n         invreg   [register] \n         Inverts the sign of the value that is stored in the specified register. Thre result is stored in the same register. \n     \n     \n         0x08 \n         eqreg   [destRegister] [registerA] [registerB] \n         Checks if the value of  registerB  and the value of  registerA  are equal. The result is either  0  or  1  and   is stored in  destRegister . \n     \n     \n         0x09 \n         neqreg   [destRegister] [registerA] [registerB] \n         Checks if the value of  registerB  and the value of  registerA  are  not  equal. The result is either  0  or  1  and is stored in  destRegister . \n     \n     \n         0x0A \n         grtreg   [destRegister] [registerA] [registerB] \n         Checks if the value of  registerA  is grater than the value of  registerB . The result is either  0  or  1  and is stored in  destRegister . \n     \n     \n         0x0B \n         letreg   [destRegister] [registerA] [registerB] \n         Checks if the value of  registerA  is less than the value of  registerB . The result is either  0  or  1  and is stored in  destRegister . \n     \n     \n         0x0C \n         jump   [register] [isAbsolute] \n         Jumps the number of  register  instructions backwards or forwards in the instruction queue relative to the current position if  isAbsolute  is zero (default). Otherwise the jump is absolute to the fist instruction (zero-based). If the value is  zero  then no jump is executed. \n     \n     \n         0x0D \n         hcall   [groupId] [functionId] \n         Executes a function in the host-application. The function to call is defined by the group-id and the function-id. For more information on how to use Host-Calls see the topic on  Host Calls .",
            "title": "Instructions"
        },
        {
            "location": "/manual/language/#host-calls",
            "text": "A  Host-Call  is a function that resists in the C++ code of the host-application and that can be called by the VM via the  hcall  instruction. This instruction takes two parameters to determine the exact function to execute.  The first parameter is the  Group-Id , this is used to group a number of functions together (mostly for organisation purposes). A group can contain up to 256 different functions.  The second parameter is the  Function-Id  which defines the index of the function in the specific group. Up to  4096  functions can be registered at the same time (total of all groups) and all can be callable via the byte-code, this number can be adjusted if fewer functions are used by the byte-code.   The byte-code can call the function via:  -- Group-Id: 0 Function-Id: 1\nhcall $0 #1  For more information about  how to implement a custom Host-Call  see the  Integration Guide",
            "title": "Host-Calls"
        },
        {
            "location": "/manual/language/#tips-tricks",
            "text": "This section features a list of useful tips and tricks that can be used to write your own Photon scripts. Some of them are used to imitate the behaviour of a higher level language like C/C++ or Java that support control structures like  if-statements  or  for-loops .  If-Statement  ToDo      For-Loop  ToDo",
            "title": "Tips & Tricks"
        },
        {
            "location": "/manual/integration-guide/",
            "text": "C++ Integration Guide\n\n\n\n\nThis page describes how the Photon scripting language can be integrated into any C++ project. Only a \nC++11\n compatible compiler is required in order to compile with Photon. The process of integrating and customizing Photon with your own C++  project will be described in the following sections.\n\n\nSetting Up Your Project\n\n\nIf you wan to add Photon support to a project, you first have to add the include directory \nPhotonVM/include\n to your projects include directories.\n\n\nPhoton does not require to link against any specific static or dynamic library at it is a \nheader-only\n library that will get compiled with the code of your own project.\n\n\nNow include the \nPhotonVM.h\n header file to get access to all parts of the virtual machine and its language. The following code-snippets shows how to create an instance of the VM that is able to execute compiled byte-code:\n\n\nPhoton::VirtualMachine virtualMachine(byteCode);\n\n\n\nalternatively the byte-code can be set after the VM has been created: \n\n\nPhoton::VirtualMachine virtualMachine;\nvirtualMachine.setByteCode(byteCode);\n\n\n\nBefore we can start the machine up, we first have to register some \nHost-Calls\n. \nHost-Calls\n are Photon's way of communicating with the host application that the VM is running in. For more information about \nHost-Calls\n see the section on \nHost-Calls\n.  \n\n\nIt is now time to get the VM running. To do so, simply call the \nrun\n method of the VM. This method executes the byte-code that was passed to the VM and returns a value that signals if any error has occurred during the execution of the code. This value can be used to e.g. show a message to the user that a script has failed to execute.\n\n\n// Execute the byte-code and check the return value.\nPhoton::VMExitCode exitCode = virtualMachine.run();\nif(exitCode != Photon::VMExitCodes::ExitCodeSuccess)\n{\n    printf(\"ERROR: Failed to execute byte-code! The VM has exited with exit code: %hu.\\n\", exitCode);\n}\n\n\n\nCompiling Byte-Code\n\n\nTo be able to execute anything on the VM compiled Byte-Code is required. This is a series of bytes that define instructions that the virtual machine can execute. This code can either be compiled directly from Photon source code or from a file that contains already pre-compiled code. This section shows both ways to get code into Photon.\n\n\n1) Compiling From Source Code\n\n\nPhoton source code can be either compiled from a file on disk or directly from an input string that contains the source code. The code below shows how to use both methods. To convert the text data into instructions that are understandable to the VM \nLexer\n is required. This Will parse the specified input and converts it into the corresponding VM instructions. For more information about instructions see the \nLanguage\n page of the documentation.  \n\n\n// Create a new lexer to parse the input code.\nPhoton::Lexer lexer;\n\n// Parse the input using the 'parse' or 'parseFromFile' method of the lexer.\nconst char* inputCode = \"setreg reg0 #12\";\nPhoton::ByteCode* byteCode = lexer.parse(inputCode);\n// OR\nPhoton::ByteCode* byteCode = lexer.parseFromFile(inputFile);\n\n\n// Report all errors of the lexer that occurred during compilation.\nwhile(lexer.hasError())\n{\n    printf(\"%s\\n\", lexer.getErrorMessage().c_str());\n}\n\n\n\n2) Loading From Byte-Code\n\n\nByte-code is an already compiled form of VM instructions that can be loaded faster than regular source code and is very small compared to the original source. The following sample shows how to load pre-compiled byte-code from a file on disk.\n\n\n// Create the byte-code object that the data gets read into.\nPhoton::ByteCode* byteCode = new Photon::ByteCode();\n\n// Load the actual byte-code from the input file.\nPhoton::loadByteCodeFromFile(inputFile, *byteCode);\n\n\n\nSimilar to the \nloadByteCodeFromFile\n function a \nwriteByteCodeToFile\n function exists which will write byte-code \nto\n a file on disk.\n\n\nCustomizing Photon\n\n\nWhen integrating Photon into your own project you are able to customize it to the needs of your application. Some of this options can be found in the \nPhotonVM.h\n header file. The following table shows a list of all global options that can be set when compiling Photon:\n\n\n\n    \n\n        \nOption\n\n        \nValues\n\n        \nDescription\n\n    \n\n    \n\n        \nPHOTON_IS_HOST_CALL_STRICT\n\n        \n0-1\n\n        \nEnable or disable strictness of host calls. If enabled and no host call can be found for an \nhcall\n instruction the VM will halt, otherwise it will continue.\n\n    \n\n    \n\n        \nPHOTON_WARNINGS_ENABLED\n\n        \n0-1\n\n        \nEnable or disable compile and runtime warnings.\n\n    \n\n    \n\n        \nPHOTON_DEBUG_CALLBACK_ENABLED\n\n        \n0-1\n\n        \nEnable or disable the user debug callback on the virtual machine. For more information see the section of this page about \nDebug Callbacks\n.\n\n    \n\n    \n\n        \nMAX_NUM_HOST_CALLS\n\n        \n1-4096\n\n        \nTotal number of host calls that can be registered at once. This can be reduced if fewer calls are used. The maximum number of calls is: 0xFFFFU = 4096U. Note that one group always consists of 256 functions.\n\n    \n\n\n\n\n\nHost-Calls\n\n\nAnother way of customizing Photon is to add application and script depended \nHost-Calls\n. \nHost-Calls\n are functions that resist in the C++ code of the host application and can be accessed from scripts to communicate with the host of the VM. They can be used to add custom behaviour to the VM or simply provide more complex instructions that are not supported by the core VM. The example below shows how to create a custom function that can be called from script and squares the value of a register.\n\n\nTo expose a function to the VM byte-code from the host-application, a class needs to be declared that defines the C++ code that will be executed on a call from the byte-code.\n\n\nclass HC_SquareValue : public Photon::IHostCallFunction\n{\npublic:\n    HC_SquareValue() : \n        IHostCallFunction(0 /*Group ID used by the VM*/, 1 /*Function ID that identifies the function*/, \"SquareValue\")\n    { }\n\n    void execute(RegisterType* registers) override\n    {\n        // Get the input of the value to compute from the reg1 register.\n        Photon::RegisterType value = registers[Photon::VirtualMachine::Reg1];\n\n        // Compute the resulting output.\n        value = value * value;\n\n        // Store the result in the reg2 register.\n        registers[Photon::VirtualMachine::Reg2] = value;\n    }   \n};\n\n\n\nIf OOP is not required for a \nHost-Call\n then alternatively the \nDECLARE_SIMPLE_HOST_CALL_BEGIN\n and \nDECLARE_SIMPLE_HOST_CALL_END\n macros can be used to automatically wrap the implementation into a class.  \n\n\nDECLARE_SIMPLE_HOST_CALL_BEGIN(HC_SquareValue, 0 /*Group ID used by the VM*/, 1 /*Function ID that identifies the function*/, \"SquareValue\")\n{\n    // Get the input of the value to compute from the reg1 register.\n    Photon::RegisterType value = registers[Photon::VirtualMachine::Reg1];\n\n    // Compute the resulting output.\n    value = value * value;\n\n    // Store the result in the reg2 register.\n    registers[Photon::VirtualMachine::Reg2] = value;\n}\nDECLARE_SIMPLE_HOST_CALL_END()\n\n\n\nAfter the \nHost-Call\n has been declared it only has to get registered with the VM that should call it. Note that the VM \ndoes not\n take over the ownership of the \nHost-Call\n instance which means that you are responsible to release the instance when it is no longer needed. Currently there is also no way to \nunregister\n a host call, this may get changed in the future.\n\n\n// Create an instance of the call and register it with the VM.\nstatic HC_SquareValue hcSquareValue;\nvirtualMachine.registerHostCallFunction(&hcSquareValue);\n\n\n\nNow a Photon script can call the function via the \nhcall\n instruction.\n\n\nsetreg reg1 #10\nhcall $0 #1\n\n\n\nDebug Callbacks\n\n\nDebug callbacks can be useful when debugging the VM. They report the decoded instruction that got executed by the VM and the current state of all registers. This information can be used to track bugs in Photon scripts. For this feature to work the \nPHOTON_DEBUG_CALLBACK_ENABLED\n option must be enabled. It is \nimportant\n that the signature of the custom callback function matches \nvoid callbackName(const Photon::Instruction& instruction, const Photon::RegisterType* registers)\n. Note that \nneither\n the instruction that was executed \nnor\n the registers themselves can be modified by the callback at any time. Also only \none\n callback can be bound to \none\n VM instance at a time. An example of a custom callback that prints the last executed instruction and current value of the \nlocal\n register to the standard output:\n\n\nvoid myCallback(const Photon::Instruction& instruction, const Photon::RegisterType* registers)\n{\n    printf(\"Instruction executed: %d, local=%d\\n\", instruction.instructionCode, registers[Photon::VirtualMachine::Local]);\n}\n\n\n\nNow the callback has to be registered with an instance of a virtual machine. Only one callback can be registered with one VM at a time. Debug callbacks always get called \nafter\n an instruction has been executed by the virtual machine.\n\n\n// Register with a virtual machine.\nvirtualMachine.setUserCallbackFunction(myCallback);",
            "title": "Integration Guide"
        },
        {
            "location": "/manual/integration-guide/#c-integration-guide",
            "text": "This page describes how the Photon scripting language can be integrated into any C++ project. Only a  C++11  compatible compiler is required in order to compile with Photon. The process of integrating and customizing Photon with your own C++  project will be described in the following sections.",
            "title": "C++ Integration Guide"
        },
        {
            "location": "/manual/integration-guide/#setting-up-your-project",
            "text": "If you wan to add Photon support to a project, you first have to add the include directory  PhotonVM/include  to your projects include directories.  Photon does not require to link against any specific static or dynamic library at it is a  header-only  library that will get compiled with the code of your own project.  Now include the  PhotonVM.h  header file to get access to all parts of the virtual machine and its language. The following code-snippets shows how to create an instance of the VM that is able to execute compiled byte-code:  Photon::VirtualMachine virtualMachine(byteCode);  alternatively the byte-code can be set after the VM has been created:   Photon::VirtualMachine virtualMachine;\nvirtualMachine.setByteCode(byteCode);  Before we can start the machine up, we first have to register some  Host-Calls .  Host-Calls  are Photon's way of communicating with the host application that the VM is running in. For more information about  Host-Calls  see the section on  Host-Calls .    It is now time to get the VM running. To do so, simply call the  run  method of the VM. This method executes the byte-code that was passed to the VM and returns a value that signals if any error has occurred during the execution of the code. This value can be used to e.g. show a message to the user that a script has failed to execute.  // Execute the byte-code and check the return value.\nPhoton::VMExitCode exitCode = virtualMachine.run();\nif(exitCode != Photon::VMExitCodes::ExitCodeSuccess)\n{\n    printf(\"ERROR: Failed to execute byte-code! The VM has exited with exit code: %hu.\\n\", exitCode);\n}",
            "title": "Setting Up Your Project"
        },
        {
            "location": "/manual/integration-guide/#compiling-byte-code",
            "text": "To be able to execute anything on the VM compiled Byte-Code is required. This is a series of bytes that define instructions that the virtual machine can execute. This code can either be compiled directly from Photon source code or from a file that contains already pre-compiled code. This section shows both ways to get code into Photon.  1) Compiling From Source Code  Photon source code can be either compiled from a file on disk or directly from an input string that contains the source code. The code below shows how to use both methods. To convert the text data into instructions that are understandable to the VM  Lexer  is required. This Will parse the specified input and converts it into the corresponding VM instructions. For more information about instructions see the  Language  page of the documentation.    // Create a new lexer to parse the input code.\nPhoton::Lexer lexer;\n\n// Parse the input using the 'parse' or 'parseFromFile' method of the lexer.\nconst char* inputCode = \"setreg reg0 #12\";\nPhoton::ByteCode* byteCode = lexer.parse(inputCode);\n// OR\nPhoton::ByteCode* byteCode = lexer.parseFromFile(inputFile);\n\n\n// Report all errors of the lexer that occurred during compilation.\nwhile(lexer.hasError())\n{\n    printf(\"%s\\n\", lexer.getErrorMessage().c_str());\n}  2) Loading From Byte-Code  Byte-code is an already compiled form of VM instructions that can be loaded faster than regular source code and is very small compared to the original source. The following sample shows how to load pre-compiled byte-code from a file on disk.  // Create the byte-code object that the data gets read into.\nPhoton::ByteCode* byteCode = new Photon::ByteCode();\n\n// Load the actual byte-code from the input file.\nPhoton::loadByteCodeFromFile(inputFile, *byteCode);  Similar to the  loadByteCodeFromFile  function a  writeByteCodeToFile  function exists which will write byte-code  to  a file on disk.",
            "title": "Compiling Byte-Code"
        },
        {
            "location": "/manual/integration-guide/#customizing-photon",
            "text": "When integrating Photon into your own project you are able to customize it to the needs of your application. Some of this options can be found in the  PhotonVM.h  header file. The following table shows a list of all global options that can be set when compiling Photon:  \n     \n         Option \n         Values \n         Description \n     \n     \n         PHOTON_IS_HOST_CALL_STRICT \n         0-1 \n         Enable or disable strictness of host calls. If enabled and no host call can be found for an  hcall  instruction the VM will halt, otherwise it will continue. \n     \n     \n         PHOTON_WARNINGS_ENABLED \n         0-1 \n         Enable or disable compile and runtime warnings. \n     \n     \n         PHOTON_DEBUG_CALLBACK_ENABLED \n         0-1 \n         Enable or disable the user debug callback on the virtual machine. For more information see the section of this page about  Debug Callbacks . \n     \n     \n         MAX_NUM_HOST_CALLS \n         1-4096 \n         Total number of host calls that can be registered at once. This can be reduced if fewer calls are used. The maximum number of calls is: 0xFFFFU = 4096U. Note that one group always consists of 256 functions.",
            "title": "Customizing Photon"
        },
        {
            "location": "/manual/integration-guide/#host-calls",
            "text": "Another way of customizing Photon is to add application and script depended  Host-Calls .  Host-Calls  are functions that resist in the C++ code of the host application and can be accessed from scripts to communicate with the host of the VM. They can be used to add custom behaviour to the VM or simply provide more complex instructions that are not supported by the core VM. The example below shows how to create a custom function that can be called from script and squares the value of a register.  To expose a function to the VM byte-code from the host-application, a class needs to be declared that defines the C++ code that will be executed on a call from the byte-code.  class HC_SquareValue : public Photon::IHostCallFunction\n{\npublic:\n    HC_SquareValue() : \n        IHostCallFunction(0 /*Group ID used by the VM*/, 1 /*Function ID that identifies the function*/, \"SquareValue\")\n    { }\n\n    void execute(RegisterType* registers) override\n    {\n        // Get the input of the value to compute from the reg1 register.\n        Photon::RegisterType value = registers[Photon::VirtualMachine::Reg1];\n\n        // Compute the resulting output.\n        value = value * value;\n\n        // Store the result in the reg2 register.\n        registers[Photon::VirtualMachine::Reg2] = value;\n    }   \n};  If OOP is not required for a  Host-Call  then alternatively the  DECLARE_SIMPLE_HOST_CALL_BEGIN  and  DECLARE_SIMPLE_HOST_CALL_END  macros can be used to automatically wrap the implementation into a class.    DECLARE_SIMPLE_HOST_CALL_BEGIN(HC_SquareValue, 0 /*Group ID used by the VM*/, 1 /*Function ID that identifies the function*/, \"SquareValue\")\n{\n    // Get the input of the value to compute from the reg1 register.\n    Photon::RegisterType value = registers[Photon::VirtualMachine::Reg1];\n\n    // Compute the resulting output.\n    value = value * value;\n\n    // Store the result in the reg2 register.\n    registers[Photon::VirtualMachine::Reg2] = value;\n}\nDECLARE_SIMPLE_HOST_CALL_END()  After the  Host-Call  has been declared it only has to get registered with the VM that should call it. Note that the VM  does not  take over the ownership of the  Host-Call  instance which means that you are responsible to release the instance when it is no longer needed. Currently there is also no way to  unregister  a host call, this may get changed in the future.  // Create an instance of the call and register it with the VM.\nstatic HC_SquareValue hcSquareValue;\nvirtualMachine.registerHostCallFunction(&hcSquareValue);  Now a Photon script can call the function via the  hcall  instruction.  setreg reg1 #10\nhcall $0 #1",
            "title": "Host-Calls"
        },
        {
            "location": "/manual/integration-guide/#debug-callbacks",
            "text": "Debug callbacks can be useful when debugging the VM. They report the decoded instruction that got executed by the VM and the current state of all registers. This information can be used to track bugs in Photon scripts. For this feature to work the  PHOTON_DEBUG_CALLBACK_ENABLED  option must be enabled. It is  important  that the signature of the custom callback function matches  void callbackName(const Photon::Instruction& instruction, const Photon::RegisterType* registers) . Note that  neither  the instruction that was executed  nor  the registers themselves can be modified by the callback at any time. Also only  one  callback can be bound to  one  VM instance at a time. An example of a custom callback that prints the last executed instruction and current value of the  local  register to the standard output:  void myCallback(const Photon::Instruction& instruction, const Photon::RegisterType* registers)\n{\n    printf(\"Instruction executed: %d, local=%d\\n\", instruction.instructionCode, registers[Photon::VirtualMachine::Local]);\n}  Now the callback has to be registered with an instance of a virtual machine. Only one callback can be registered with one VM at a time. Debug callbacks always get called  after  an instruction has been executed by the virtual machine.  // Register with a virtual machine.\nvirtualMachine.setUserCallbackFunction(myCallback);",
            "title": "Debug Callbacks"
        },
        {
            "location": "/manual/using-pvm/",
            "text": "Using PVM\n\n\n\n\nTogether with the VM header files also comes a simple implementation of the VM called the \nPVM\n. This command line program implements all basic functionality that is needed to execute any Photon script. The source can be found in the \n/source\n directory of the project. To build the \nPVM\n you have to generate the corresponding project file(s) (\nVS 2015/XCode/Makefiles\n) for your platform using \nCMake\n.\n\n\nPVM supports three basic operations that can be executed via command-line parameters:\n\n\n\n\nCompile from Photon source to byte-code\n\n\nExecute Photon source code\n\n\nExecute compiled byte-code\n\n\n\n\nPVM uses a slightly different syntax for command line arguments than other applications. Instead of \n-option foo\n it uses \n-option=foo\n.\nThe following sections show how to use PVM on the command line.\n\n\nCompile to byte-code\n\n\nTo compile source code to executable byte-code an input and output file have to be specified. If no output is specified the compiler will default to \n./byteCode.pbc\n.\n\n\nAt least an input file has to be specified using the \n-c\n parameter in order to compile to byte-code. Note that the order of the different parameters are not important.\n\n\npvm -c=./MyCode.pho -o=./MyOutput.pbc\n\n\n\nExecute source code\n\n\nTo compile and run source code in the VM use the following syntax:\n\n\npvm -r=./MyCode.pho\n\n\n\nExecute byte-code\n\n\nThe syntax of running already compiled byte-code is pretty similar to executing non-compiled code:\n\n\npvm -b=./MyCode.pbc\n\n\n\nFor more information about the command-line options use the \n-h\n command of PVM which will show the help message.",
            "title": "Using PVM"
        },
        {
            "location": "/manual/using-pvm/#using-pvm",
            "text": "Together with the VM header files also comes a simple implementation of the VM called the  PVM . This command line program implements all basic functionality that is needed to execute any Photon script. The source can be found in the  /source  directory of the project. To build the  PVM  you have to generate the corresponding project file(s) ( VS 2015/XCode/Makefiles ) for your platform using  CMake .  PVM supports three basic operations that can be executed via command-line parameters:   Compile from Photon source to byte-code  Execute Photon source code  Execute compiled byte-code   PVM uses a slightly different syntax for command line arguments than other applications. Instead of  -option foo  it uses  -option=foo .\nThe following sections show how to use PVM on the command line.",
            "title": "Using PVM"
        },
        {
            "location": "/manual/using-pvm/#compile-to-byte-code",
            "text": "To compile source code to executable byte-code an input and output file have to be specified. If no output is specified the compiler will default to  ./byteCode.pbc .  At least an input file has to be specified using the  -c  parameter in order to compile to byte-code. Note that the order of the different parameters are not important.  pvm -c=./MyCode.pho -o=./MyOutput.pbc",
            "title": "Compile to byte-code"
        },
        {
            "location": "/manual/using-pvm/#execute-source-code",
            "text": "To compile and run source code in the VM use the following syntax:  pvm -r=./MyCode.pho",
            "title": "Execute source code"
        },
        {
            "location": "/manual/using-pvm/#execute-byte-code",
            "text": "The syntax of running already compiled byte-code is pretty similar to executing non-compiled code:  pvm -b=./MyCode.pbc  For more information about the command-line options use the  -h  command of PVM which will show the help message.",
            "title": "Execute byte-code"
        },
        {
            "location": "/reference/vm-architecture/",
            "text": "VM Architecture\n\n\n\n\nThis section describes the architecture that is used to create the core of the Photon VM.\nThe core consists of a list of registers that the compiled byte-code can operate on. The following graphic shows an overview of the core architecture of the VM.\n\n\n\n\nRegisters\n\n\nPhoton's core consists of \n13\n different registers of which \n12\n can be used by the user code or as result registers for more complex host calls. The minimum value that a register can hold is \n-2\n32\n and the maximum is \n2\n32\n-1\n. The registers are grouped into three categories: \n\n\n\n\n\n\nGeneral use registers. These range from \nreg0\n to \nreg5\n and are only used by the user code and no external modification should be made to these registers other than the instructions that are defined by the user.\n\n\n\n\n\n\nTemporary registers. These range from \ntmp0\n to \ntmp5\n and can be used for host calls or other computations as output or working registers. It is not guaranteed that a value that is set by the user will \nnot\n get  overwritten by any external code.\n\n\n\n\n\n\nSpecial purpose registers. These include the \nlocal\n register. This register is only used for short-time storage because it is \nnot\n guaranteed that the value will not get overwritten by one of the following instructions. Use it to transfer data from one instruction to the next.\n\n\n\n\n\n\nNote that the VM does \nnot\n support string and floating-point types. If string types are needed, for example as identifier, then use string hashing at compile time level or plain indices instead. \n\n\nInstruction Encoding\n\n\nInstruction codes in Photon are encoded into 16-bit unsigned integer values. These contain all data of an instruction so the VM is able to decode and execute it on the fly.\n\n\nValues (or scalars/constants) are encoded in the last 8-bits of the instruction, so the VM supports values in a range from \n0-255\n. The data gets placed from the last-significant-bit position:\n\n\n| 7| 6| 5| 4| 3| 2| 1| 0|\n\n\n\nThe parameters are stored using 4-bits for all:\n\n\n|11|10| 9| 8|\n\n\n\nThe first 4-bits are used to store the instruction type:\n\n\n|15|14|13|12|\n\n\n\nAs an example, an instruction that loads a constant value into a VM register would be represented as following:\n\n\nsetreg   reg2   #30\n-------------------------\n0001     0010   00011110 => 0x121E\n\n\n\nNote that registers can store values that are \ngreater than 255\n, e.g. as the result of an addition.\nSome instructions use three parameters to define their behaviour, this works by splitting the 8-bit constant section into two 4-bit sections. This works because registers \nnever\n exceed the \n0x0 - 0xF\n range so they can be stored using only 4-bits.\n\n\nHalt Instruction\n\n\nThe halt instruction is similar to C/C++ \nreturn\n or \nexit\n. It can indicate an error in the VM byte-code that can either be emitted by the VM itself, e.g. by an \nout of bounds jump\n or a \ndivide by zero\n. The halt instruction does not need to take any parameter, in this case it \nwill always\n return success to the host-application. The host-application can query the last exit code from the VM via the \ngetExitCode()\n method.\n\n\nPhoton defines a fixed number of exit codes that can be emitted by the VM itself to report internal errors that are critical and should halt the VM immediately. The following table shows all internal exit codes:\n\n\n\n    \n\n        \nExit Code\n\n        \nCode Name\n\n        \nDescription\n\n    \n\n    \n\n        \n0\n\n        \nExitCodeSuccess\n\n        \nSignals success.\n\n    \n\n    \n\n        \n1\n\n        \nExitCodeDivideByZero\n\n        \nSignals a division by zero error.\n\n    \n\n    \n\n        \n2\n\n        \nExitCodeJumpOutOfBounds\n\n        \nSignals that the offset of a jump-instruction is out of bounds.\n\n    \n\n    \n\n        \n3\n\n        \nExitCodeRegisterFault\n\n        \nSignals that the byte-code tried to access an invalid register.\n\n    \n\n    \n\n        \n4\n\n        \nExitCodeInvalidHostCall\n\n        \nSignals that a host call function was requested but could not be found. This will only be signalled if \nPHOTON_IS_HOST_CALL_STRICT\n is enabled.\n\n    \n\n    \n\n        \n5\n\n        \nExitCodeUserCode\n\n        \nFirst error code that should be used by any non VM code. User errors should start at \nExitCodeUserCode + userCodeNumber\n as they will otherwise conflict with the above values.\n\n    \n\n\n\n\n\nIf the result of the VM execution is greater or equal to \nExitCodeUserCode\n then the exit code is emitted by the user byte-code.\n\n\nThe exit code is returned from the \nrun()\n method of the VM instance or alternatively by calling \ngetExitCode()\n on the VM instance.\n\n\nPhoton::VMExitCode code = virtualMachine.run();\n// OR\nPhoton::VMExitCode code = virtualMachine.getExitCode();\n\n// Check the exit code for success.\nif(code != Photon::VMExitCodes::ExitCodeSuccess)\n{\n    printf(\"The VM has exited with exit code: %d.\\n\", code);\n}\nelse\n{   \n    printf(\"VM successfully finished!\");\n}",
            "title": "VM Architecture"
        },
        {
            "location": "/reference/vm-architecture/#vm-architecture",
            "text": "This section describes the architecture that is used to create the core of the Photon VM.\nThe core consists of a list of registers that the compiled byte-code can operate on. The following graphic shows an overview of the core architecture of the VM.",
            "title": "VM Architecture"
        },
        {
            "location": "/reference/vm-architecture/#registers",
            "text": "Photon's core consists of  13  different registers of which  12  can be used by the user code or as result registers for more complex host calls. The minimum value that a register can hold is  -2 32  and the maximum is  2 32 -1 . The registers are grouped into three categories:     General use registers. These range from  reg0  to  reg5  and are only used by the user code and no external modification should be made to these registers other than the instructions that are defined by the user.    Temporary registers. These range from  tmp0  to  tmp5  and can be used for host calls or other computations as output or working registers. It is not guaranteed that a value that is set by the user will  not  get  overwritten by any external code.    Special purpose registers. These include the  local  register. This register is only used for short-time storage because it is  not  guaranteed that the value will not get overwritten by one of the following instructions. Use it to transfer data from one instruction to the next.    Note that the VM does  not  support string and floating-point types. If string types are needed, for example as identifier, then use string hashing at compile time level or plain indices instead.",
            "title": "Registers"
        },
        {
            "location": "/reference/vm-architecture/#instruction-encoding",
            "text": "Instruction codes in Photon are encoded into 16-bit unsigned integer values. These contain all data of an instruction so the VM is able to decode and execute it on the fly.  Values (or scalars/constants) are encoded in the last 8-bits of the instruction, so the VM supports values in a range from  0-255 . The data gets placed from the last-significant-bit position:  | 7| 6| 5| 4| 3| 2| 1| 0|  The parameters are stored using 4-bits for all:  |11|10| 9| 8|  The first 4-bits are used to store the instruction type:  |15|14|13|12|  As an example, an instruction that loads a constant value into a VM register would be represented as following:  setreg   reg2   #30\n-------------------------\n0001     0010   00011110 => 0x121E  Note that registers can store values that are  greater than 255 , e.g. as the result of an addition.\nSome instructions use three parameters to define their behaviour, this works by splitting the 8-bit constant section into two 4-bit sections. This works because registers  never  exceed the  0x0 - 0xF  range so they can be stored using only 4-bits.",
            "title": "Instruction Encoding"
        },
        {
            "location": "/reference/vm-architecture/#halt-instruction",
            "text": "The halt instruction is similar to C/C++  return  or  exit . It can indicate an error in the VM byte-code that can either be emitted by the VM itself, e.g. by an  out of bounds jump  or a  divide by zero . The halt instruction does not need to take any parameter, in this case it  will always  return success to the host-application. The host-application can query the last exit code from the VM via the  getExitCode()  method.  Photon defines a fixed number of exit codes that can be emitted by the VM itself to report internal errors that are critical and should halt the VM immediately. The following table shows all internal exit codes:  \n     \n         Exit Code \n         Code Name \n         Description \n     \n     \n         0 \n         ExitCodeSuccess \n         Signals success. \n     \n     \n         1 \n         ExitCodeDivideByZero \n         Signals a division by zero error. \n     \n     \n         2 \n         ExitCodeJumpOutOfBounds \n         Signals that the offset of a jump-instruction is out of bounds. \n     \n     \n         3 \n         ExitCodeRegisterFault \n         Signals that the byte-code tried to access an invalid register. \n     \n     \n         4 \n         ExitCodeInvalidHostCall \n         Signals that a host call function was requested but could not be found. This will only be signalled if  PHOTON_IS_HOST_CALL_STRICT  is enabled. \n     \n     \n         5 \n         ExitCodeUserCode \n         First error code that should be used by any non VM code. User errors should start at  ExitCodeUserCode + userCodeNumber  as they will otherwise conflict with the above values. \n       If the result of the VM execution is greater or equal to  ExitCodeUserCode  then the exit code is emitted by the user byte-code.  The exit code is returned from the  run()  method of the VM instance or alternatively by calling  getExitCode()  on the VM instance.  Photon::VMExitCode code = virtualMachine.run();\n// OR\nPhoton::VMExitCode code = virtualMachine.getExitCode();\n\n// Check the exit code for success.\nif(code != Photon::VMExitCodes::ExitCodeSuccess)\n{\n    printf(\"The VM has exited with exit code: %d.\\n\", code);\n}\nelse\n{   \n    printf(\"VM successfully finished!\");\n}",
            "title": "Halt Instruction"
        },
        {
            "location": "/reference/assembly-lexer/",
            "text": "",
            "title": "Assembly Lexer"
        }
    ]
}