/*********************************************************************************
 * Copyright (c) 2015-2016 by Niklas Grabowski (C-574)                           *
 *                                                                               *
 * Permission is hereby granted, free of charge, to any person obtaining a copy  *
 * of this software and associated documentation files (the "Software"), to deal *
 * in the Software without restriction, including without limitation the rights  *
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell     *
 * copies of the Software, and to permit persons to whom the Software is         *
 * furnished to do so, subject to the following conditions:                      *
 *                                                                               *
 * The above copyright notice and this permission notice shall be included in    *
 * all copies or substantial portions of the Software.                           *
 *                                                                               *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR    *
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,      *
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE   *
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER        *
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, *
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN     *
 * THE SOFTWARE.                                                                 *
 *********************************************************************************/
#ifndef _PHOTON_LEXER_H_
#define _PHOTON_LEXER_H_

// Include all needed prerequisites of the library.
#include "PhotonPrerequisites.h"
#include "VirtualMachine.h"



namespace Photon
{


/*----------------------------------------------------------------------------------------------------------------
 * Basic Syntax Befinitions
 *--------------------------------------------------------------------------------------------------------------*/  


/** Character that is used as a prefix for group ids. */
static const char SYNTAX_GROUP_ID_PREFIX = '$';
/** Character that is used as a prefix for constant values. */
static const char SYNTAX_CONSTANT_VALUE_PREFIX = '#';
/** String that defineds the beginning of a code comment. */
static const char SYNTAX_COMMENT_BEGIN[] = "--";

/*----------------------------------------------------------------------------------------------------------------
 * 
 *--------------------------------------------------------------------------------------------------------------*/  


/**
 * \brief This class is a lexer that is able to compile Photon code and transform it into byte code that can be executed by the VM.
 * 
 * To compile either a string of Photon source code or source code from a file use the parse or parseFromFile method of the lexer to generate
 * PhotonVM byte code that can be executed by the VM. To check whether the compilation process has succeeded or failed use the hasError method in combination
 * with the getErrorMessage method to get the errors that were produced by the lexer while parseing the source code. Note that these errors will be
 * reset in the next call to a parse method.
 */
class Lexer
{
public:
	/** Constructor of a lexer. */
	Lexer() : 
		m_TailNode(nullptr),
		m_HeadNode(nullptr),
		m_InstructionCount(0)
	{
	}

	/** Destructor of a lexer. */
	~Lexer()
	{
		releaseNodeList();
	}

	/*----------------------------------------------------------------------------------------------------------------
	 * 
	 *--------------------------------------------------------------------------------------------------------------*/  

	/** Parses Photon source code and generates byte code from it that can be executed by the Virtual Machine. 
	 * \param	sourceCode	Photon source code to parse as an ASCII string.
	 * \return	Returns	either the generated byte code or <b>nullptr</b> if the parsing failed. If so, get the last error message using getErrorMessage(). */
	ByteCode* parse(const char* sourceCode)
	{
		// Make sure the list is empty.
		releaseNodeList();

		// Reset all errors from any previous compilation.
		clearErrors();

		// Reset the instruction count.
		m_InstructionCount = 0;

		// Split the source code into multiple lines.
		std::vector<std::string> lines = splitString(sourceCode, '\n');

		// Line number of a token.
		uint32_t lineNumber = 1;

		// Iterate over the line list and build the token nodes.
		std::vector<std::string>::iterator it = lines.begin();
		while(it != lines.end())
		{
			// Tokenize the line and get the created node list part.
			InstructionNode* node = tokenizeLine(*it, lineNumber);
			if(!node)
			{
				// Increment the line number.
				lineNumber++;

				++it;
				continue;
			}

			// Set the tail node if none is set.
			if(!m_TailNode)
				m_TailNode = node;
			
			if(!m_HeadNode)
				m_HeadNode = node;
			else
				m_HeadNode->nextNode = node;

			// Update the head of the list.
			updateNodeHead(m_HeadNode);

			// Increment the line number.
			lineNumber++;

			++it;
		}

		/* TODO: Add an optimizer step to optimize byte code.
		 * This could include: remove duplicate instructions following eachother, remove
		 * start initailizers to zero or inlining specific code (only needed when functions 
		 * are supported).
		 *   => optimizeInstructionNodeList(); */

		// Now generate the byte code from the token list.
		ByteCode* byteCode = generateByteCode();

		return byteCode;
	}


	/*----------------------------------------------------------------------------------------------------------------
	 * 
	 *--------------------------------------------------------------------------------------------------------------*/  

	/** Parses Photon source code from a file and generates byte code from it that can be executed by the Virtual Machine. 
	 * \param	fileName	Path to a file that contains Photon source code to parse.
	 * \return	Returns	either the generated byte code or <b>nullptr</b> if the parsing failed. If so, get the last error message using getErrorMessage(). */
	ByteCode* parseFromFile(const char* fileName)
	{
		FILE*    file;
		long	 fileSize;
		char*	buffer;
		size_t   result;

		// MSVC specific version using the _s version to make the compiler happy.
#ifdef _PHOTON_COMPILER_MSVC
		errno_t error = fopen_s(&file, fileName, "rb");
		if(error)
		{
			// Failed to open the file.
			addError("ERROR: Failed to open file: \"" + std::string(fileName) + "\"! No such file or directory.");
			return nullptr;
		}
#else
		// Try to open the specified file in text, read-only mode.
		file = fopen(fileName, "rb");
		if(!file)
		{
			// Failed to open the file.
			addError("ERROR: Failed to open file: \"" + std::string(fileName) + "\"! No such file or directory.");
			return nullptr;
		}
#endif //_PHOTON_COMPILER_MSVC


		// Get the file size from the file.
		fseek(file, 0L, SEEK_END);
		fileSize = ftell(file);
		fseek(file, 0L, SEEK_SET);

		// Create a buffer that contains all file data.
		buffer = static_cast<char*>(calloc(1, fileSize + 1));
		if(!buffer) 
		{
			// Failed to allocate the file buffer to read to.
			addError("ERROR: Failed to allocate file buffer!");
			fclose(file);
			return nullptr;
		}

		// Read the whole file into the buffer.
		result = fread(buffer, fileSize, 1, file);
		if(result != 1)
		{
			// Failed to read the data into the buffer.
			addError("ERROR: Failed to read file \"" + std::string(fileName) + "\"! Unexpected read error.");
			free(buffer);
			fclose(file);
			return nullptr;
		}

		// Parse the source code and generate the corresponding byte code.
		ByteCode* byteCode = parse(buffer);


		// Close the file and release the buffer.
		fclose(file);
		free(buffer);

		// Return the generated byte code.
		return byteCode;
	}


	/*----------------------------------------------------------------------------------------------------------------
	 * 
	 *--------------------------------------------------------------------------------------------------------------*/  

	/** Check if the error queue contains at least one error message. */
	bool hasError() const
	{
		return !m_ErrorQueue.empty();
	}

	/** Get the next error code from the error queue. */
	const std::string getErrorMessage()
	{
		// Get the first entry and remove it.
		const std::string error = m_ErrorQueue.front();
		m_ErrorQueue.pop();
		return error;
	}

	/** Get the total number of executable instructions that the byte code contains. */
	const uint32_t getInstructionCount() const
	{
		return m_InstructionCount;
	}

private:
	/** This structure contains all data of <b>one</b> element of an instruction.
	 * for the element <i>"setreg"</i> the type would be NodeTypeInstruction and the value would be <i>"setreg"</i>. */
	struct InstructionNode
	{
		/** Enumeration of all possible node types. */
		enum NodeType
		{
			NodeTypeInstruction,	///< The node contains a VM instruction as the value.
			NodeTypeRegister,		///< The node contains a VM register as the value.
			NodeTypeGroupId,		///< The node contains a Host-Call function-group id.
			NodeTypeValue,			///< The node contains a constant/scalar as the value.
			NodeTypeNextInstruction	///< The following node is a new instruction. The current node will be ignored.
		};

		/*----------------------------------------------------------------------------------------------------------------
		 * 
		 *--------------------------------------------------------------------------------------------------------------*/  


		/** Constructor of an instruction node.
		 * \param	type		Type of the node to construct.
		 * \param	value		The value of the node as a Unicode string. Default is empty.
		 * \param	lineNumber	Line number of the token in the source code. */
		InstructionNode(NodeType type, const std::string& value = "", uint32_t lineNumber = 0) :
			nextNode(nullptr),
			code(InstructionHalt),
			registerIndex(VirtualMachine::Reg0),
			dataValue(0)
		{
			this->type		 = type;
			this->value		 = value;
			this->lineNumber = lineNumber;
		}

		/** Destructor of an instruction node. */
		~InstructionNode()
		{
		}
		
		/*----------------------------------------------------------------------------------------------------------------
		 * 
		 *--------------------------------------------------------------------------------------------------------------*/  


		/** Next instruction element that follows the current one. */
		InstructionNode* nextNode;

		/** Type of the node. For more info see \ref NodeType. */
		NodeType type;

		/** Value of the node as a Unicode string. */
		std::string value;

		/** Instruction code of the node, this value is not valid if the node type is not NodeTypeInstruction. */
		InstructionCode code;

		/** Register index of the node. Only valid if the node type is NodeTypeRegister. */
		VirtualMachine::Register registerIndex;

		/** Data value of the node as an instruction parameter. */
		uint8_t dataValue;

		/** Line number or the instruction node in the source code. */
		uint32_t lineNumber;
	};

private:

	/** Releases the instruction node list. */
	void releaseNodeList()
	{
		// Go to the tail of the list and iterate over it.
		InstructionNode* currentNode = m_TailNode;

		while(currentNode)
		{
			// Save the current node.
			InstructionNode* tempNode = currentNode;

			// Unlink the current node.
			currentNode = currentNode->nextNode;

			// Delete the unlinked node.
			delete tempNode;
		}

		// Reset head and tail.
		m_TailNode = nullptr;
		m_HeadNode = nullptr;
	}

	/** Tokenizes a source code line and generates instruction nodes that will be appended to the node list.
	 * \param	line		Line of Photon source code to tokenize into nodes. 
	 * \param	lineNumber	Number of the currently parsed line.
	 * \return	Returns the tokenized string as instruction nodes. 
	 * \bug		Inline comments, like "instr blah #4 -- Comment" are currently not supported. */
	InstructionNode* tokenizeLine(std::string& line, const uint32_t& lineNumber)
	{
		/* The removal of line endings is only required for Windows CR+LF endings. 
		 * On Linux it seems to work without it. */
#ifdef _PHOTON_COMPILER_MSVC
		// Remove \r line endings at the end.
		if(line.at(line.size() - 1) == '\r')
			line.at(line.size() - 1) = ' ';
#endif

		// Get the tokens from the list.
		std::vector<std::string> tokens = splitString(line, ' ');

		// Reset the start node of the line.
		InstructionNode* startNode	 = nullptr;
		InstructionNode* currentNode = nullptr;

		// Iterate over the tokens.
		std::vector<std::string>::const_iterator it = tokens.begin();
		while(it != tokens.end())
		{
			// Get the current token.
			const std::string& token = (*it);

			// If the line is empty or a comment, skip it.
			if(token.empty() || (token.substr(0, 2) == SYNTAX_COMMENT_BEGIN))
			{
				return nullptr;
			}

			// Convert the string to a node type.
			InstructionNode::NodeType type = convertToNodeType(token);

			// Create a new node from the token.
			InstructionNode* node = new InstructionNode(type, token, lineNumber);

			// Set the start node if this is the first node in the line.
			if(!startNode)
				startNode = node;

			// Store the old current node as it will ge overwritten.
			InstructionNode* tempNode = currentNode;

			// Set the new node as the current one.
			currentNode = node;

			// Link in the newly created node with the previous one.
			if(tempNode)
				tempNode->nextNode = currentNode;



			// Switch on the node type to setup the node.
			switch(type)
			{
			case InstructionNode::NodeTypeInstruction:
				node->code = convertToInstructionCode(token, node->lineNumber);

				// Add the instruction to the counter.
				m_InstructionCount++;

				break;
			case InstructionNode::NodeTypeRegister:
				node->dataValue = convertToRegisterIndex(token, lineNumber);
				break;
			case InstructionNode::NodeTypeGroupId:
				node->dataValue = convertToConstantValue(token, lineNumber, SYNTAX_GROUP_ID_PREFIX /* Uses '$' as group id number prefix. */);
				break;
			case InstructionNode::NodeTypeValue:
				node->dataValue = convertToConstantValue(token, lineNumber);
				break;
			default:
				break;
			}

			++it;
		}

		// Appand a new instruction node to signal the beginning of a new instruction.
		if(currentNode)
			currentNode->nextNode = new InstructionNode(InstructionNode::NodeTypeNextInstruction);

		// Return the start of the line nodes.
		return startNode;
	}

	/** Creates VM instructions and the corresponding byte code from the generated token list. 
	 * \return	Returns a byte code structure that can be used to run the VM or <b>nullptr</b> if the byte code generation failed. */
	ByteCode* generateByteCode()
	{
		// Create a raw instruction buffer that will contain all packed byte code instructions.
		RawInstruction* instructionBuffer = new RawInstruction[m_InstructionCount];

		// Instruction that is used to generate the byte code.
		Instruction instruction;

		if(!generateNodeByteCode(m_TailNode, instructionBuffer, m_InstructionCount, 0, instruction, 0))
		{
			addError("ERROR: Failed to generate byte code instructions!");
			return nullptr;
		}

		// Create the byte code that stores the byte code instruction data.
		ByteCode* byteCode = new ByteCode(instructionBuffer, m_InstructionCount);

		return byteCode;
	}

	/** Generates the instruction byte code of the specified node and all of the following nodes.
	 * \param	node				Node to start generating the byte code from. 
	 * \param	instructionBuffer	Buffer that contains enough space to store all generated raw instructions. 
	 * \param	bufferSize			Number of raw instructions that the buffer can store.
	 * \param	bufferIndex			Index of the current instruction in the instruction buffer.
	 * \param	instruction			VM instruction that is currently being generated.
	 * \param	parameterCount		Total number of parameters on the current instruction.
	 * \return	Returns <b>true</b> if the byte code generation was successfull, otherwise it returns <b>false</b>. */
	bool generateNodeByteCode(InstructionNode* node, RawInstruction* instructionBuffer, uint32_t bufferSize, uint32_t bufferIndex, Instruction& instruction, uint16_t parameterCount)
	{		
		// Ignore invalid input and return.
		if(!node || !instructionBuffer)
			return true;


		if(node->type == InstructionNode::NodeTypeInstruction)
		{
			// Clear the instruction and set the instruction code.
			instruction.clear();
			instruction.instructionCode = node->code;

			// Reset the parameter count.
			parameterCount = 0;
		}
		else if(node->type == InstructionNode::NodeTypeRegister)
		{
			// Check the parameter count to see which parameter should be filled.
			if(parameterCount == 0)
				instruction.param1 = node->dataValue;
			else if(parameterCount == 1)
				instruction.param2 = node->dataValue;
			else if(parameterCount == 2)
				instruction.param3 = node->dataValue;
			else
			{
				addError("ERROR: Invalid amount of parameters for VM instruction! Maximum is: 3, got: " + std::to_string(parameterCount) + ".");
				return false;
			}

			// Increment the parameter count.
			parameterCount++;
		}
		else if(node->type == InstructionNode::NodeTypeGroupId)
		{
			// Check if the value is greater than the maximum number of groups.
			if(node->dataValue > 0xF)
			{
				addError("ERROR: Group ID of host call function is out of bounds! Maximum is: 15, got: " + std::to_string(node->dataValue) + ".");
				return false;
			}

			// Store the group id and increment the parameter count.
			instruction.param1 = node->dataValue;
			parameterCount++;
		}
		else if(node->type == InstructionNode::NodeTypeValue)
		{
			// Set the value to the value parameter of the instruction.
			instruction.value = node->dataValue;

			// Make sure to clear the param2 register if the instruction is 'setreg'.
			if(instruction.instructionCode == InstructionSetRegister)
				instruction.param3 = node->dataValue;

			// Increment the parameter count.
			parameterCount++;
		}
		else if(node->type == InstructionNode::NodeTypeNextInstruction)
		{
			// Check if the buffer index is valid.
			if(bufferIndex >= bufferSize)
			{
				addError("ERROR: Instruction buffer overflow! Requested: " + std::to_string(bufferIndex) + + ", got: " + std::to_string(bufferSize) + ".");
				return false;
			}

			// We are done with this instruction, so pack and store it.
			RawInstruction rawInstrution = VirtualMachine::packInstruction(instruction);
			instructionBuffer[bufferIndex] = rawInstrution;

			// Increment the buffer inex for the next instruction.
			bufferIndex++;
		}

		// Generate all following nodes.
		return generateNodeByteCode(node->nextNode, instructionBuffer, bufferSize, bufferIndex, instruction, parameterCount);
	}

	/*----------------------------------------------------------------------------------------------------------------
	 * UTILLITY METHODS
	 *--------------------------------------------------------------------------------------------------------------*/  


	/** Splits a string into a list of strings that are split based on the specified delimiter.
	 * \param	input	Input string to split.
	 * \param	delim	Character that specifies the delimiter to split on.
	 * \param	output	Output list that will be filled with the splitted strings. */
	std::vector<std::string>& splitString(const std::string& input, char delim, std::vector<std::string>& output) 
	{
		std::stringstream ss(input);
		std::string item;
		while (std::getline(ss, item, delim)) {
			output.push_back(item);
		}
		return output;
	}

	/** Splits a string into a list of strings that are split based on the specified delimiter.
	 * \param	input	Input string to split.
	 * \param	delim	Character that specifies the delimiter to split on.
	 * \return	Returns a list that is filled with the splitted strings. */
	std::vector<std::string> splitString(const std::string& s, char delim) 
	{
		std::vector<std::string> elems;
		splitString(s, delim, elems);
		return elems;
	}

	/** Check if the specified string a number or not.
	 * \param	input	Input string to check.
	 * \return	Returns <b>true</b> if the string is a number or <b>false</b> if it is not a number. */
	bool isNumber(const std::string& input)
	{
		std::string::const_iterator it = input.begin();
		while (it != input.end() && std::isdigit(*it))
			++it;
		return !input.empty() && it == input.end();
	}

	/** Moves the list head forward until it reaches the end of the list. 
	 * \param	startNode	Node to start updating upwards. */
	void updateNodeHead(InstructionNode* startNode)
	{
		// Go to the tail of the list and iterate over it.
		InstructionNode* currentNode = startNode;

		while(currentNode)
		{
			// Move forward in the list.
			if(!currentNode->nextNode)
				m_HeadNode = currentNode;
			currentNode = currentNode->nextNode;
		}
	}


	/*----------------------------------------------------------------------------------------------------------------
	 * STRING CONVERTER METHODS
	 *--------------------------------------------------------------------------------------------------------------*/  

	/** Convert a specified string to a node type. 
	 * \param	input	Input string to convert.
	 * \return	Returns a node type. */
	InstructionNode::NodeType convertToNodeType(const std::string& input)
	{
		// Check if the string is a register.
		if((input == "local") || (((input.substr(0, 3) == "reg") || (input.substr(0, 3) == "tmp")) && input.size() <= 4))
			return InstructionNode::NodeTypeRegister;
		// Check if the string is a constant number.
		else if(input.at(0) == SYNTAX_CONSTANT_VALUE_PREFIX || isNumber(input))
			return InstructionNode::NodeTypeValue;
		// Check if the string is a group id.
		else if(input.at(0) == SYNTAX_GROUP_ID_PREFIX || isNumber(input))
			return InstructionNode::NodeTypeGroupId;
		// Otherwise we assume it is an instruction.
		return InstructionNode::NodeTypeInstruction;
	}

	/** Convert a specified string to an instruction. 
	 * \param	input		Input string to convert.
	 * \param	lineNumber	Line number of the instruction string in the source code. Used for error handling.
	 * \return	Returns an instruction code. */
	InstructionCode convertToInstructionCode(const std::string& input, const uint32_t& lineNumber)
	{
		if(input == "halt")
			return InstructionHalt;
		else if(input == "dumpreg")
			return InstructionDumpRegister;
		else if(input == "setreg")
			return InstructionSetRegister;
		else if(input == "cpyreg")
			return InstructionCopyRegister;
		else if(input == "addreg")
			return InstructionAddRegister;
		else if(input == "subreg")
			return InstructionSubRegister;
		else if(input == "mulreg")
			return InstructionMulRegister;
		else if(input == "divreg")
			return InstructionDivRegister;
		else if(input == "invreg")
			return InstructionInvRegister;
		else if(input == "eqreg")
			return InstructionEqRegister;
		else if(input == "neqreg")
			return InstructionNeqRegister;
		else if(input == "grtreg")
			return InstructionGrtRegister;
		else if(input == "letreg")
			return InstructionLetRegister;
		else if(input == "jump")
			return InstructionJump;
		else if(input == "hcall")
			return InstructionCallHost;
	

		// Emit an error.
		addError("ERROR: Unknown instruction \"" + input + "\" in line " + std::to_string(lineNumber) + "!");
		return InstructionHalt;
	}

	/** Convert a specified string to a register index. 
	 * \param	input		Input string to convert.
	 * \param	lineNumber	Line number of the instruction string in the source code. Used for error handling.
	 * \return	Returns an instruction code. */
	VirtualMachine::Register convertToRegisterIndex(const std::string& input, const uint32_t& lineNumber)
	{
		uint16_t registerOffset = 0;

		// Check if the input is either 'local' or one of the 'reg/tmp' registers.
		if((input != "local") && ((input.substr(0, 3) != "reg")) && (input.substr(0, 3) != "tmp"))
		{
			addError("ERROR: Unknown register name \"" + input + "\" in line " + std::to_string(lineNumber) + "!");
			return VirtualMachine::Reg0;
		}

		// Check explicitly for the local register.
		if(input == "local")
			return VirtualMachine::Local;

		// Offset the temporary registers as they start with an index of 6 but start labeling at 0.
		if(input.at(0) == 't')
			registerOffset += VirtualMachine::Tmp0;

		// Return the number of the specified register.
		return (static_cast<VirtualMachine::Register>(stoi(input.substr(3, 2)) + registerOffset));
	}


	/** Convert a specified string to a constant/scalar value. 
	 * \param	input		Input string to convert.
	 * \param	lineNumber	Line number of the instruction string in the source code. Used for error handling.
	 * \param	prefix		Prefix character of the constant value, e.g. '#' for simple values or '$' for group ids. Default is defined by SYNTAX_CONSTANT_VALUE_PREFIX.
	 * \return	Returns a constant/scalar value in a range from 0 to 255. */
	uint8_t convertToConstantValue(const std::string& input, const uint32_t& lineNumber, const char prefix = SYNTAX_CONSTANT_VALUE_PREFIX)
	{
		// Check if the value is marked as a constant value.
		if(input.at(0) != prefix)
		{
			addError("ERROR: Invalid definition of a constant value in line " + std::to_string(lineNumber) + ": \"" + input + "\"! Are you missing '" + prefix + "' in front of the constant definition? ");
			return 0xffU;
		}

		// Get the actual number from the string but skip the '#'.
		int32_t value = stoi(input.substr(1));

		// Check if the value is out of the range from 0 to 255.
		if(value < 0 || value > 255)
		{
			addError("ERROR: Invalid definition of a constant value in line " + std::to_string(lineNumber) + ": \"" + input + "\"! Value is out of the valid range from 0 to 255.");
			return 0xffU;
		}

		// If the value is valid then return it.
		return value;
	}

	
	/*----------------------------------------------------------------------------------------------------------------
	 * ERROR HANDLING 
	 *--------------------------------------------------------------------------------------------------------------*/  

	/** Add a message to the error queue. 
	 * \param	errorMessage	Error message as a Unicode string. */
	void addError(const std::string& errorMessage)
	{
		m_ErrorQueue.push(errorMessage);
	}

	/** Clears all error messages in the queue. */
	void clearErrors()
	{
		while(!m_ErrorQueue.empty())
			m_ErrorQueue.pop();
	}

private:
	/** The tail node of the list that defines the start of the node list. */
	InstructionNode* m_TailNode;

	/** Head node of the list. A new node will be appanded to this node. */
	InstructionNode* m_HeadNode;

	/** Total number of executable instructions in the token list. This excludes NextInstruction nodes. */
	uint32_t m_InstructionCount;

	/** Queue of error messages that were emmited by the lexer while parsing. */
	std::queue<std::string> m_ErrorQueue;
};


} /* End of Photon namespace. */

#endif //_PHOTON_LEXER_H_
